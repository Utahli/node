# Java Data Types - Java 数据类型

JVM 可以操作的数据类型分为两类: primitive types 和 reference types. 类型检查通常在编译期完成，不同指令操作数的类型可以通过虚拟机的字节码指令本身确定。

### Primitive type

JVM 所支持的基本数据类型有：数值类型(Numeric types), 布尔类型(Boolean type) 和 returnAddress 类型。其中数值类型又可以分为整型和浮点型两种。

- 整型：byte(8 bit), short(16 bit), int(32 bit), long(64 bit), char(16 bit unsigned)
- 浮点型：float(32 bit), double(64 bit)
- 布尔型：boolean 通常用 int 型表示，Oracle 中用 byte 表示
- returnAddress：指向一条虚拟机指令的操作码 ，returnAddress类型在Java语言之中并不存在相应的类型，而且也无法在程序运行期间更改。 

### Reference type

引用类型分为三种：Class Types, Array Types 和 Interface Types, 这些引用类型的值分别由类实例、数组实例和实现了某个接口的类实例或者数组实例动态创建。引用类型中有一特殊的值`null`, 引用类型的默认值就是 null.

### java 基本数据类型

Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作

### 一.基本数据类型

Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。

**byte：**

- byte数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是-128（-2^7）；最大值是127（2^7-1）；默认值是0；
- **byte类型用在大型数组中节约空间**，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；
- 例子：byte a = 100，byte b = -50。

**short：**

- short数据类型是16位、有符号的，以二进制补码表示的整数
- 最小值是-32768（-2^15）；最大值是32767（2^15 - 1）；
- Short数据类型也可以像byte那样**节省空间**。一个short变量是int型变量所占空间的二分之一；
- 例子：short s = 1000，short r = -20000。

**int：**

- int数据类型是32位，有符号的，以二进制补码表示的整数；
- 最小值是-2,147,483,648（-2^31）；最大值是2,147,485,647（2^31 - 1）；
- 一般地整型变量默认为int类型；
- 例子：int a = 100000, int b = -200000。

**long：**

- long数据类型是64位、有符号的，以二进制补码表示的整数；
- 最小值是-9,223,372,036,854,775,808（-2^63）；最大值是9,223,372,036,854,775,807（2^63 -1）；
- 这种类型主要使**用在需要比较大整数的系统上**；
- 例子： long a = 100000L，int b = -200000L。

**float：**

- float数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- 1位符号位+8位指数位（q）+23位底数位（b），即b^q；
- float在储存大型浮点数组的时候可节省内存空间；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

**double：**

- double数据类型是双精度、64位、符合IEEE 754标准的浮点数；
- 1位符号位+11位指数位（q）+52位底数位，即b^q；
- 浮点数的默认类型为double类型；
- double类型同样不能表示精确的值，如货币；
- 例子：double d1 = 123.4。

**boolean：**

- boolean数据类型表示一位的信息；只有两个取值：true和false；
- 默认值是false；

**char：**

- char类型是一个单一的16位Unicode字符；
- 最小值是’\u0000’（即为0）；
- 最大值是’\uffff’（即为65,535）；
- char数据类型可以储存任何字符；
- 例子：char letter = ‘A’。

**Summary：**

byte,short,int,long 均为有符号的、二进制补码表示的整数，不同在于占用空间情况,实际使用时可根据内存情况选择。其各自可表示的范围为（-2^(x-1)~2^(x-1)-1）;

float,double表示的均是浮点数，不同之一在于其各自精度不同(精度体现在尾数的位数上)，之二在于可表示的范围(由于其各自占用空间不同)。

​	Java决定了每种简单类型的大小。这些大小并不随着机器结构的变化而变化。这种大小的不可更改正是Java程序具有很强移植能力的原因之一。

​	Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。基本类型的优势：数据存储相对简单，运算效率比较高.包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想

**JAVA包装类：**

Java语言是一个面向对象的语言，但**Java****中的基本数据类型却是不面向对象**的，这在实际使用时存在很多的不便，为解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，**这样八个和基本数据类型对应的类统称为包装类****(Wrapper Class)**，也译为外覆类或数据类型类。所有的包装类都是抽象类Number的子类。包装类均位于java.lang包。

对于包装类说，这些类的用途主要包含两种：

​                   a、作为和基本数据类型对应的类类型存在，**方便涉及到对象的操作**。

​                   b、包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。

## 二.引用类型

- 引用类型变量**由类的构造函数创建**，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。**变量一旦声明后，类型就不能被改变了。**
- **对象、数组都是引用数据类型**。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用与任何与之兼容的类型。
- 例子：Animal animal = new Animal(“giraffe”)。

## 三.Java常量

常量就是一个固定值。它们不需要计算，直接代表相应的值。常量指不能改变的量。 在Java中**用final标志**，声明方式和变量类似。

 

# PART TWO：Java 变量类型

Java语言支持的变量类型有：

- 局部变量
- 成员变量
- 类变量

## 一.Java局部变量

- 局部变量**声明在方法、构造方法或者语句块**中(被创建，且仅在其内可见)； 当它们执行完成后，变量将会被销毁；
- 访问修饰符不能用于局部变量；
- 局部变量是**在栈上分配的**。
- **局部变量没有默认值**，所以局部变量量被声明后，**必须初始化后，**才可以使用**。**

## 二.实例变量

- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；
- 当一个对象被实例化之后，每个实例变量的值就跟着确定；
- **实例变量在对象创建的时候创建，在对象被销毁的时候销毁；**
- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；
- 实例变量可以声明在使用前或者使用后；
- **访问修饰符可以修饰实例变量**（package(默认)、private、public和protected）**；**
- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；
- **实例变量具有默认值。**数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；
- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：**ObejectReference.VariableName**。

## 三.类变量（静态变量）

- 类变量也称为静态变量，**在类中以static关键字声明**，但必须在方法构造方法和语句块之外。
- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。
- 静态变量储存在**静态存储区**。经常被声明为常量，很少单独使用static声明变量。
- 静态变量在程序开始时创建，**在程序结束时销毁。**
- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
- 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。
- 静态变量可以通过：**ClassName.VariableName**的方式访问。
- 类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。

## 形式参数传递

基本类型作为形式参数传递不会改变实际参数，引用类型作为形式参数传递会改变实际参数。JDK1.5之后含有基本类型的包装类型，即自动拆装箱的功能，故将基本类型的相应对象作为参数传递时会自动拆箱为基本类型，故也不改变实际参数的值。

只有 boolean 不参与数据类型的转换 
2、自动类型的转换：

> a.常数在表数范围内是能够自动类型转换的 
> b.数据范围小的能够自动数据类型大的转换（注意特例） 
> c. float 到 int，float 到 long，double 到 int，double 到 long 等由浮点类型转换成整数类型时，是不会自动转换的，不然将会丢失精度。 
> d.引用类型能够自动转换为父类的 
> e.基本类型和它们包装类型是能够互相转换的



# java基本数据类型自动转换规则

## Java基本数据类型转换

Java语言是一种强类型的语言。强类型的语言有以下几个要求： 
（1） 变量或常量必须有类型，而且只能在声明以后才能使用； 
（2） 赋值时类型必须一致，值的类型必须和变量或常量的类型完全一致； 
（3） 运算时类型必须一致，参与运算的数据类型必须一致才能运算。 
但在实际应用中，经常需要在不同类型的值之间进行操作，这时就需要进行数据类型的转换。 
数据类型转换有两种： 
（1） 自动类型转换：编译器自动完成类型转换，不需要在程序中编写代码； 
规则：从存储范围小的类型到存储范围大的类型。 
具体规则：byte→short(char)→int→long→float→double. 
（2） 强制类型转换：强制编译器进行类型转换，必须在程序中编写代码。该类型转换很可能存在精度的损失。 
规则：从存储范围大的类型到存储范围小的类型。 
具体规则：double→float→long→int→short(char)→byte. 

## 一、java基本数据类型

Java提供了八种基本类型，其中包括六种数字类型(四个整数型，两个浮点型)，一种字符类型和一种布尔型。 
整型： short, int, long, byte； 
浮点型：float, double； 
字符型：char； 
布尔型：boolean. 
Java中的数值类型**不存在无符号的**，它们的取值范围是固定的，不会随着机器硬件环境或[操作系统](http://lib.csdn.net/base/operatingsystem)的改变而改变。

![](D:\workspace\Github\node\瑞秋\answer\assets\20170803091350470.png)

## 二、非赋值运算，自动转换规则

### 1）布尔型不参与转换

### 2）规则： byte/char/short -> int ->  long -> float -> double

2.1）例子：

```
public class Test {
	public static void main(String[] args) {
		short a = 1;
		byte b = 2;
		char c = 3;
		
		//三个输出都是 class java.lang.Integer
		System.out.println(getType(b+a));
		
		System.out.println(getType(b+c));
		
		System.out.println(getType(a+c));
		
	}
	
	public static String getType(Object o){
		return o.getClass().toString();
		}
}

```

### 2.2）规则具体讲解

（2.2.1）如操作数之一为double，则另一个操作数先被转化为double，再参与算术运算。 
（2.2.2）如两操作数均不为double，当操作数之一为float，则另一操作数先被转换为float，再参与运算。 
（2.2.3）如两操作数均不为double或float，当操作数之一为long，、则另一操作数先被转换为long，再参与算术运算。 
（2.2.4）如两操作数均不为double、float或long，则两操作数先被转换为int，再参与运算。 

3）对比一下C语言

![](D:\workspace\Github\node\瑞秋\answer\assets\20170803092718878.png)

## 三、赋值运算，自动转换规则

将小范围类型变量转换成大范围类型的变量。Java会自动扩宽类型

看上面那张图，各个基本数据类型的取值范围都有了，如果一个取值范围包括了另一个的，那么赋值时，小的可以自动转换成大的

例子：     long d = 333;   float e = d; //可以

short a = 1; char b = a; //不行，因为取值范围不是包含，而是交叉

int a = 1; byte b = a; //不行，大的转成小的，要强制类型转换，byte b = (byte) a;

四、一些值得注意的地方

当运算符为取正运算符（+）。取负运算符（-）或按位取反运算符（~）时，如果操作数为byte、char或short，则先被转换为int，再参与运算

## 1、自动类型转换

自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。

**转换规则：从存储范围小的类型到存储范围大的类型。**

具体规则为：byte→short(char)→int→long→float→double

也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码：

byte b=10;
short sh=b;

这里在给sh赋值时，JVM首先将b的值转换成short类型然后再赋值给sh。

当然，在类型转换的时候也可以跳跃，就是byte也可以自动转换为int类型的。

注意问题：在整数之间进行类型转换的时候数值不会发生变化，但是当将整数类型特别是比较大的整数类型转换成小数类型的时候，由于存储精度的不同，可能

会存在数据精度的损失。

## 2、强制类型转换

强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种

损失时才进行该类型的转换。

转换规则:从存储范围大的类型到存储范围小的类型。

具体规则为：double→float→long→int→short(char)→byte

语法格式为：(转换到的类型)需要转换的值

double d=3.14;
int i=(int) d;

注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。

## **三、常见面试题：**

1、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?

答：对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。

对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。

2、char类型变量能不能储存一个中文的汉子，为什么？

char类型变量是用来储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的，还有一种特殊情况就是某个生僻字没有包含在

unicode编码字符集中，那么就char类型就不能存储该生僻字。

3、Integer和int的区别

int是java的8种内置的原始数据类型。Java为每个原始类型都提供了一个封装类，Integer就是int的封装类。

int变量的默认值为0，Integer变量的默认值为null，这一点说明Integer可以区分出未赋值和值为0的区别，比如说一名学生没来参加考试，另一名学生参加考

试全答错了，那么第一名考生的成绩应该是null，第二名考生的成绩应该是0分。关于这一点Integer应用很大的。

Integer类内提供了一些关于整数操作的一些方法，例如上文用到的表示整数的最大值和最小值。

4、switch语句能否作用在byte上，能否作用在long上，能否作用在string上？

byte的存储范围小于int，可以向int类型进行隐式转换，所以switch可以作用在byte上

long的存储范围大于int，不能向int进行隐式转换，只能强制转换，所以switch不可以作用在long上

string在1.7版本之前不可以，1.7版本之后switch就可以作用在string上了。



## **一、基本数据类型的类型转换**

基本数据类型中，布尔类型boolean占有一个字节，由于其本身所代码的特殊含义，**boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）， 否则，将编译出错**。

1.基本数据类型中数值类型的自动类型提升

数值类型在内存中直接存储其本身的值，对于不同的数值类型，内存中会分配相应的大小去存储。如:byte类型的变量占用8位，int类型变量占用32位等。相应的，不同的数值类型会有与其存储空间相匹配的取值范围。具体如下所示：

![](D:\workspace\Github\node\瑞秋\answer\assets\804968-c97646615cbedf4b.png)

图中依次表示了各数值类型的字节数和相应的取值范围。**在Java中，整数类型（byte/short/int/long）中，对于未声明数据类型的整形，其默认类型为int型。在浮点类型（float/double）中，对于未声明数据类型的浮点型，默认为double型。**

将一个int型的3赋给一个byte型的变量c，居然编译正确，这是为什么呢？

原因在于：**jvm在编译过程中，对于默认为int类型的数值时，当赋给一个比int型数值范围小的数值类型变量（在此统一称为数值类型k，k可以是byte/char/short类型），会进行判断，如果此int型数值超过数值类型k，那么会直接编译出错。**因为你将一个超过了范围的数值赋给类型为k的变量，k装不下嘛，你有没有进行强制类型转换，当然报错了。**但是如果此int型数值尚在数值类型k范围内，jvm会自定进行一次隐式类型转换，将此int型数值转换成类型k。如图中的虚线箭头。这一点有点特别，需要稍微注意下。**

**在其他情况下，当将一个数值范围小的类型赋给一个数值范围大的数值型变量，jvm在编译过程中俊将此数值的类型进行了自动提升。在数值类型的自动类型提升过程中，数值精度至少不应该降低（整型保持不变，float->double精度将变高）。**

**还有一个地方需要注意的是：char型其本身是unsigned型，同时具有两个字节，其数值范围是0 ~ 2^16-1，因为，这直接导致byte型不能自动类型提升到char，char和short直接也不会发生自动类型提升（因为负数的问题），同时，byte当然可以直接提升到short型。**

2.基本数据类型中的数值类型强制转换

当我们需要将数值范围较大的数值类型赋给数值范围较小的数值类型变量时，由于**此时可能会丢失精度**（1讲到的从int到k型的隐式转换除外），我们称之为强制类型转换。

将一个值为3的int型变量a赋值给byte型变量b，发生编译错误。这两种写法之间有什么区别呢？

**区别在于前者3是直接量，编译期间可以直接进行判定，后者a为一变量，需要到运行期间才能确定，也就是说，编译期间为以防万一，当然不可能编译通过了。****此时，需要进行强制类型转换。**强制类型转换所带来的结果是可能会丢失精度，如果此数值尚在范围较小的类型数值范围内，对于整型变量精度不变，但如果超出范围较小的类型数值范围内，很可能出现一些意外情况。

如下经典例子：

1packagecom.corn.testcast;23publicclassTestCast {45publicstaticvoidmain(String[] args) {6inta = 233;7byteb = (byte) a;8System.out.println("b:" + b);//输出：-239}1011}

**为什么结果是-23？需要从最根本的二进制存储考虑。**

233的二进制表示为：24位0 + 11101001，byte型只有8位，于是从高位开始舍弃，截断后剩下：11101001，由于二进制最高位1表示负数，0表示正数，其相应的负数为-23。

3.进行数学运算时的数据类型自动提升与可能需要的强制类型转换

1packagecom.corn.testcast;23publicclassTestCast {45publicstaticvoidmain(String[] args) {6bytea = 3 + 5;//编译正常 编译成 3+5直接变为87intb = 3, c = 5;8byted = b + c;//编译错误：cannot convert from int to byte910bytee = 10, f = 11;11byteg = e + f;//编译错误 +直接将10和11类型提升为了int12byteh = (byte) (e + f);//编译正确13}1415}

**当进行数学运算时，数据类型会自动发生提升到运算符左右之较大者**，以此类推。当将最后的运算结果赋值给指定的数值类型时，可能需要进行强制类型转换。