## **一、基础篇**

### **1.1、Java基础**

#### 面向对象的特征：继承、封装和多态



**什么是封装？**
==信息隐藏，指利用抽象数据类型将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型的内部，隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过这些接口与这个封装的对象进行交互。==
**封装的好处：**
1、使调用者正确、方便的使用系统功能，防止调用者随意修改系统属性。
2、提高组件的重用性；
3、良好的封装能够减少耦合（当某一个模块实现发生变化时，只要对外暴露的接口不变，就不会影响到其他模块）。
**封装如何暴露和隐藏呢？访问权限控制：**
private:表示私有的，表示类访问权限，只能在本类中访问，离开本类之后，就不能直接访问；
不写(缺省)：表示包私有，表示包访问权限，访问者的包必须和当前定义类的包相同才能访问；
protected：表示子类访问权限，同包中的可以访问，即使不同包，但是有继承关系，也可以访问；

public：表示全局的，可以公共访问权限，如果某个字段/方法使用了public修饰，则可以在当前项目中任何地方访问。



**什么是继承关系：**
 继承是使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以覆盖父类的某些特性。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。
继承是一种从一般到特殊的关系，是一种“is a”的关系，即子类是对父类的拓展
在Java中，类和类之间的继承关系**只允许单继承，不允许多继承。但是Java允许多重继承**。
在Java中除了Object类之外，每一个类都有一个直接的父类，
**继承关系的作用：**
1)解决了代码的重复问题；
2)**真正的作用，表示出一个体系。子类继承了父类的哪些成员（根据访问修饰符来判断）：**
1)如果父类中的成员使用public修饰，子类继承；
2)如果父类中的成员使用protected修饰，子类也继承，即使父类子类不在同一个包；
3)如果父类和子类在同一个包中，此时子类可以继承父类中缺省修饰符的成员；
4)如果父类中的成员使用private修饰，子类打死都继承不到，因为private只能在本类中访问；
5)父类的构造器，子类也不能访问，因为构造器必须和当前的类名相同。

==编译器会默认给子类调用父类的构造器==。

​    ==但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用指定的父类构造器，而且必须是在子类构造器中做的第一件事(第一行代码)否，则编译器会报错：无法找到符合父类形式的构造器。==

​    对于**子类**而言，==当且仅当只有一个**方法可以**在构造器中调用父类构造器来完成初始化**==。

==继承存在如下缺陷：==

==1、父类变，子类就必须变。==

==2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。==

==3、继承是一种强耦合关系。==



**多态：（当我们代码变成以下样子时，多态就产生了）**
==一个引用变量指向哪个类的实例对象，该引用变量发出的方法调用是哪个类中实现的方法，必须在由程序运行期间才能决定。在程序运行时所绑定的具体代码，让程序可以选择多个运行状态的特性，就是多态性。==

​    ==对于面向对象而言，多态分为**编译时多态**和**运行时多态**。其中**编辑时多态是静态的，主要是指方法的重载**，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而**运行时多态是动态的，它是通过动态绑定来实现的，它是真正的多态性。**==
**多态的前提：**可以是继承关系（类和类）/也可以是实现关系（接口和实现类），在开发中多态一般指第二种。
**多态的特点：**把子类对象赋给父类变量，在运行时期会表现出具体的子类特征。
**多态的作用：**当把不同的子类对象都当做父类类型来看待，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。

==Java实现多态有三个必要条件：继承、重写、向上转型。==

==对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用引用子类对象时，是被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。==

 **在Java中有两种形式可以实现多态：继承和接口。**

 **基于继承实现的多态**

​    ==基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为==。

​    基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。

​    如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。

 **基于接口实现的多态**

接口 Interface

​    继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。

​    在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

​    ==继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。==

 **继承链调用优先级**

==在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。==

**==当超类对象引用变量引用子类对象时，是被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，不过仍然要按照继承链中调用方法的优先级来确认。==**



#### 重载和重写的区别

- 重载overloading

  就是==一个类里有两个或更多名字相同而参数不同的函数==.==每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。==

- 覆写overriding

  ==发生在子类中！在子类中可以用自己的逻辑去实现继承的父类的方法==

==重载 静态捆绑 (static binding) 是 编译时多态==

==覆写 动态捆绑 (dynamic binding) 是 运行时多态==

==1、重载是一个编译期概念、重写是一个运行期间概念。==

==2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。==

==3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法==

==4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）==

==构造器不能被继承所以不能被 重写 但可以被重载（构造器名称与类名相同）==

==方法重载是**一个类的多态性表现**,而方法重写是子类与父类的一种多态性表现。==



#### final, finally, finalize 的区别

**1、final 修饰符（关键字）**

==final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量(在方法中的或者代码块中的变量称为本地变量) 。==

如果类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。 

将变量或者方法声明为final，可以保证他们在使用中不被改变。final成员变量的初始化可以在两个地方：一是其定义处，也就是说，在final变量定义时直接给其赋值；二是构造函数中。这2个地方只能选其一，要么在定义处直接给其赋值，要么在构造函数中给值，并且在以后的引用中，只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写。==final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。== 

**使用final关键字的好处**

1. ==final关键字提高了性能。JVM和Java应用都会缓存final变量。==
2. ==final变量、final类可以安全的在多线程环境下进行共享，而不需要额外的同步开销。==
3. 使用final关键字，JVM会对方法、变量及类进行优化。

 关于final的重要知识点

1. final关键字可以用于成员变量、本地变量、方法以及类。
2. ==final成员变量必须在**声明的时候初始化**或者**在构造器中初始化**，否则就会报编译错误。==
3. 你不能够对final变量再次赋值。
4. ==本地变量必须在声明时赋值。==
5. ==在匿名类中所有变量都必须是final变量。==
6. ==final方法不能被重写。==
7. ==final类不能被继承。==
8. final关键字不同于finally关键字，后者用于异常处理。
9. final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
10. ==接口中声明的所有变量本身是final的。==
11. ==final和abstract这两个关键字是反相关的，final类就不可能是abstract的。==
12. ==final方法在编译阶段绑定，称为静态绑定(static binding)。==
13. ==没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。==
14. 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
15. 按照Java代码惯例，final变量就是常量，而且通常常量名要大写

 **2、finally(用于异常处理)**

​     ==一般是用于异常处理中，提供finally块来执行任何的清除操作，finally结构使代码总会执行，不关有无异常发生。==

 ==finally在try,catch中可以有，可以没有。如果trycatch中有finally则必须执行finally快中的操作。====一般情况下，用于关闭文件的读写操作，或者是关闭数据库的连接等等。==

==**两种情况下finally语句是不会被执行的：**==

==**（1）try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行**==

==**（2）在try块中有System.exit(0);语句，System.exit(0);是终止Java虚拟机JVM的，JVM停止了，finally语句也不会被执行到。**==

==**finally块的语句在try或catch中的return语句执行之后返回之前执行，且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回** 。==

 **3、finalize（用于垃圾回收）**

finalize是方法名。它是Object类中定义的，因此，所有的类都继承了它。finalize()方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 使用finalize还需要注意一个事，调用super.finalize(); ==**一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象（JVM另起一个低优先级的线程去执行finalize()方法），所以有可能调用finalize()后，该对象又不需要被回收了**，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，==产生问题。 一般来说，不推荐使用finalize()方法，它跟析构函数不一样。 

 **final, finally, finalize的区别**

- final 是Java的一个保留的关键字，用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.
- finally 是异常处理语句结构的一部分，表示无论异常是否发生，都会执行finally块的内容 
- finalize 是Object类的一个方法，这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.



#### Exception、Error、运行时异常与一般异常有何异同

![](D:\workspace\Github\node\瑞秋\201\assets\20180309211054853.jpg)

Java对异常进行了分类，所有异常的根类为java.lang.Throwable

==Throwable下面又派生了两个子类：Error和Exception==

Error：表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 

**Error：表示由JVM所侦测到的无法预期的错误，描述了java运行时系统的内部错误和资源耗尽错误。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。**

**Exception：表示可恢复的操作，这是可捕捉到的。 这个层次结构又分解为连个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。==划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有没有问题，但由于像I/O错误这类异常导致的异常属于非运行时异常。==** 

==Java提供了两类主要的异常**:runtime exception和checked exception**。checked 异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。**这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误.**==

==但是另外一种异常：runtime exception，也称运行时异常，在编译的时候不需要检查 (checked)。包括运行时异常（RuntimeException）和派生于Error类的异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。==

==出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。==

 处理异常的方法

1. try catch.
2. throws.

这两种方法有什么区别

==第一种方法是自己处理异常.==

==第二种异常是把异常抛给调用这个方法的模块去处理.==

#### 请写出5种常见到的runtime exception

IndexOutOfBoundsException(下标越界异常) 

NullPointerException(空指针异常) 

ClassNotFoundException

NumberFormatException （String转换为指定的数字类型异常） 

ArithmeticException -（算术运算异常 如除数为0） 

ArrayStoreException - （向数组中存放与声明类型不兼容对象异常）

SecurityException -（安全异常）



#### int 和 Integer 有什么区别，Integer的值缓存范围

  (1）Ingeter是int的包装类，是一个类，int是基本类型 

（2）int的初值为0，Ingeter的初值为null。

（3）int 是在栈里创建的，Integer是在堆里创建的。栈里创建的变量要比在堆创建的速度快得多。

（1）Integer参与数学运算时，会自动拆箱。

（2）Integer（常量池中）和new Integer对象（堆中）相比，地址永远不相等。

（3）两个非new的Integer对象相比，在-128~127中进行缓存，这个范围则相等。

（4）两个都是new出来的Integer永远不相等，在堆中的两个不同地址。

（5）Integer作为一个类，作为方法参数传递时，传递的还是值，而不是地址。

   (6）在==比较时只会经历拆箱过程，在=赋值时会出现拆箱和装箱过程。 

[-128,127]

#### 包装类，装箱和拆箱

Java语言是一个面向对象的语言，但**Java中的基本数据类型却是不面向对象**的，这在实际使用时存在很多的不便，为解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，**这样八个和基本数据类型对应的类统称为包装类****(Wrapper Class)**，也译为外覆类或数据类型类。==所有的包装类都是抽象类Number的子类。包装类均位于java.lang包。==

==对于包装类说，这些类的用途主要包含两种：==

​== a、作为和基本数据类型对应的类类型存在，**方便涉及到对象的操作**。==

==b、包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。==

==**装箱**： 可以自动将基本类型直接转换成对应的包装类型。 **拆箱**： 自动将包装类型转换成对应的基本类型值；==

装箱拆箱是通过调用`Integer.valueOf()`（装箱） 和 `Integer.initValue()`（拆箱）来完成的。

装箱操作会判断基本类型值是否在`IntegerCache.cache`数组范围内，如果在，返回`IntegerCache.cache`数组中对应下标的元素。否则，才新建一个对象。

==`IntegerCache.cache`是一个final的Integer数组，这个数组存储的Integer对象元素的值范围是[-128，127]。而且这个数组的初始化代码是包裹在static代码块中，也就是说`IntegerCache.cache`**数组的初始化是在类加载时完成的。**==

- ==包装类与String类很相似，都是非可变类，即一经创建后，便不可以修改。正因为这种特性，两者的对象实例在多线程下是安全的，不用担心异步修改的情况，这为他们实现共享提供了很好的保证，只需创建一个对象共享便可。==
- ==包装类的共享实现并不是由JVM来维护一个常量池，而是使用了缓存机制（数组），而且这个缓存是在类加载时完成初始化，并且不可再修改。==
- ==包装类的数组缓存范围是有限，只缓存基本类型值在一个字节范围内，也就是说 -128 ~ 127。（Character的范围是 0~127）==
- ==目前并不是所有包装类都提供缓存机制，只有Byte、Character、Short、Integer 4个包装类提供，Long、Float、Double 不提供。==



#### String、StringBuilder、StringBuffer

三者之间的区别：

==都是final类，都不允许被继承；==

==String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；==

==StringBuffer类是线程安全的，StringBuilder不是线程安全的；==

#### String 和 StringBuffer：

1、String类型和StringBuffer类型的主要性能区别：==String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，==所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；

2、==使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，==所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；

3、====**在运行期间，String字符串通过 + 来链接的表达式计算都是通过创建StringBuilder来完成的**==

==**String 在克隆时只是克隆了它的引用。**==

==String的equals方法 ： **先比较引用是否相同(是否是同一对象)，再检查是否为同一类型（str instanceof String）， 最后比较内容是否一致（String 的各个成员变量的值或内容是否相同）。这也同样适用于诸如 Integer 等的八种包装器类。==

**对于String类型的字面常量，必须要在 字符串常量池 中维护一个全局的引用。当遇到字符串常量时要先去字符串池中寻找是否存在这个常量，如果有，则返回对应的引用。如果没有，则创建对象并添加到字符串常量池中，然后返回新创建对象的引用。**

 **字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的**



#### 抽象类和接口有什么区别

**接口和抽象类都是继承树的上层，他们的共同点如下：**
1)	都是上层的抽象层。
2)	都不能被实例化
3)	都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现。

**他们的区别如下：**
1)	在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2)	一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。

3）实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现

4） ==抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。==

5）抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。==**抽象类是对类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。**

 6）==跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可；但是接口不同，实现它的子类可以不存在任何关系抽象类所体现的是一种继承关系，父类和派生类之间是"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。==

7） ==设计层次不同。对于抽象类而言，它是自底向上设计的，我们要先知道子类才能抽象出父类，而接口则不同，它自顶向下设计的，接口根本就不需要知道子类的存在，只需要定义一个规则即可，至于有什么子类、什么时候怎么实现它一概不知。==

 **四、总结**

​      ==1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。==

==​      2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。==

​==      3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。==

​	Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。

​	接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。
对于已经存在的继承树，可以方便的从类中抽象出新的接口，但是从类中抽象出新的抽象类就不那么容易了，因此接口更有利于软件系统的维护和重构。

 **一、抽象类**

抽象类是用来描述抽象行为的，体现了数据抽象的思想，是实现多态的一种机制。为其子类提供一个公共的类型，封装子类中得重复内容（成员变量和方法），子类虽然有不同的实现，但是定义是一致的。抽象方法的具体表现形式由子类来实现。

 **二、接口**

​      接口是抽象方法的集合，且不能实例化，没有构造体，所有方法都是抽象的 (abstract).同时也是隐式的 public. 也就是说声明时, 可以省略 public abstract，只能含有声明为 final static 的属性  。

JAVA的类可以被实现许多个接口，然而一个接口则无法实现其他的接口。

​	Java接口本身没有任何实现，因为Java接口不涉及表象，而只描述public行为，所以Java接口比Java抽象类更抽象化。但是接口不是类，不能使用new 运算符实例化一个接口。 

​      接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。

​      **在使用接口过程中需要注意如下几个问题：**

​         1、1个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！

​         2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。

​         3、==接口中不存在实现的方法。==

​         4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。

​         5、==不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。==

​         6、在实现多接口的时候一定要避免方法名的重复。



#### equals与==的区别

- **== 比较引用的地址**
- **equel 比较引用的内容** (Object 类本身除外)



#### Java的平台无关性如何体现出来的

==在 Java 应用程序和操作系统之间有一个虚拟层—— JRE（Java运行环境），JRE由JVM和一下类库组成，JVM拥有自己的指令集，在运行时操作不同的内存区域，其主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，它是实现Java跨平台的核心。所有的Java程序首先会编译成.class类文件，类文件的组成包括 JVM 指令集，符号表以及一些补助信息。 .class文件不直接与操作系统交互，而是由JRE里的JVM将程序解释给本地系统去执行，通过JVM间接的与操作系统交互，从而实现了Java程序的可移植性。== 



#### JDK和JRE的区别

==JRE是java运行环境。包含了JVM和JVM解释.class文件需要类库lib==

==JDK是Java环境的核心组件，并提供编译、调试和运行一个Java程序所需的所有工具，可执行文件和二进制文件。==

**JDK是用于java程序的开发,而jre则 是只能运行class而没有编译的功能。**

**JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。**

JVM 是 Java 平台的基础，是整个java实现跨平台的最核心的部分,它有自己的指令集，并且在运行时操作不同的内存区域，其主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，提供了一种与平台无关的代码执行方法。所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。

#### Java 8有哪些新特性



#### hashCode和equals方法的区别与联系

- 在Java中任何一个对象都具备equals(Object obj)和hashcode()这两个方法，因为他们是在Object类中定义的。  
- equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。  
- ==hashcode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。==  

关于这两个方法的重要规范：

==规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值==。

==规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。==

==**在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！**== 

==注意一下，String，Integer，Date这些类重写了equals()方法，不再是比较类在堆内存中的存放地址了。==



#### Object类中常见的方法，为什么wait  notify会放在Object里边？

**一.Object类中的toString()方法** 

==object 默认方法 toString方法，toString() 输出一个对象的地址字符串（哈希code码）！== 

**二.Object类中的equals()方法** 
==Object类equals()比较的是对象的引用是否指向同一块内存地址！== 

**Object()** 
默认构造方法 
**clone()** 
创建并返回此对象的一个副本。 
**finalize()** 
当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
**getClass()** 
返回一个对象的运行时类。 
**hashCode()** 
返回该对象的哈希码值。 

**wait(),sleep()区别？** 
wait():释放资源，释放锁 
sleep():释放资源，不释放锁

**notify()** 
唤醒在此对象监视器上等待的单个线程。 
**notifyAll()** 
唤醒在此对象监视器上等待的所有线程。 
**wait()** 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 
**wait(long timeout)** 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 
**wait(long timeout, int nanos)** 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。

**为什么wait  notify会放在Object里边？(考点：线程通信机制)**

1. ==`wait`和`nofity`不是常见的普通java方法或同步工具，在Java中它们更多的是实现两个线程之间的通信机制。 如果不能通过类似`synchronized`这样的Java关键字来实现这种机制，那么`Object`类中就是定义它们最好的地方，以此来使任何Java对象都可以拥有实现线程通信机制的能力。记住`synchronized`和`wait`,`notify`是两个不同的问题域，并且不要混淆它们的相似或相关性。 同步类似竞态条件，是提供线程间互斥和确保Java类的线程安全性的，而`wait`和`notify`是两个线程之间的通信机制。==
2. ==每个对象都可以作为锁，这是另一个原因`wait`和`notify`在Object类中声明，而不是Thread类。==
3. ==在Java中，为了进入临界区代码段，线程需要获得锁并且它们等待锁可用，它们不知道哪些线程持有锁而它们只知道锁是由某个线程保持，它们应该等待锁而不是知道哪个线程在同步块内并要求它们释放锁。 这个比喻适合等待和通知在`object`类而不是Java中的线程。==



#### 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用

序列化：把对象转换为字节序列的过程称为对象的序列化。

反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

​        ==java对象序列化不仅保留一个对象的数据，而且**递归保存对象引用的每个对象的数据**。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的“深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象的序列。==

==**对象序列化保存的是对象的”状态”，即它的成员变量**。由此可知，对象序列化不会关注类中的静态变量。反之亦然。支持序列化和反序列化的基本类型有：String，Array，Enum和Serializable，如果非以上的一种，那么会抛出NotSerializableException异常。==

**==Externalizable进行序列化和反序列化会比较麻烦，因为需要重写序列化和反序列化的方法，序列化的细节需要手动完成。当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。因此，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。==** 

```java
public class User implements Externalizable {

    private String name;

    private transient String password;

    // 必须要有无参构造器
    public User() {
        System.out.println("constructor");
    }


    // 序列化User对象
    public void writeExternal(ObjectOutput out) throws IOException {
        System.out.println("writeExternal");
        out.writeObject(name);
        out.writeObject(password);
    }

    // 反序列化User对象
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        System.out.println("readExternal");
        name = (String) in.readObject();
        password = (String) in.readObject();
    }

    // 不会被执行
    private void writeObject(ObjectOutputStream out) throws IOException {
        System.out.println("writeObject");
    }

    // 不会被执行
    private void readObject(ObjectInputStream in) throws IOException {
        System.out.println("readObject");
    }

    // 在writeExternal之前执行，只是为了说明执行顺序，实际不需要写。
    private Object writeReplace() throws ObjectStreamException {
        this.setName("kobe");
        System.out.println("writeReplace");
        return this;
    }

    // 在readExternal之后执行，只是为了说明执行顺序，实际不需要写。
    private Object readResolve() throws ObjectStreamException {
        this.setName("kobe");
        System.out.println("readresolve");
        return this;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" +
                ", name='" + name + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```



==transient 修饰的属性，是不会被序列化的。==

==静态static的属性，不序列化。==

==**反序列化后类中static型变量为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的**==

==在序列化过程中，虚拟机会试图调用对象类里的writeObject() 和readObject()，进行用户自定义的序列化和反序列化，如果没有则调用ObjectOutputStream.defaultWriteObject() 和ObjectInputStream.defaultReadObject()。同样，在ObjectOutputStream和ObjectInputStream中最重要的方法也是writeObject() 和 readObject()，递归地写出/读入byte。==

==​        所以用户可以通过writeObject()和 readObject()自定义序列化和反序列化逻辑。对一些敏感信息加密的逻辑也可以放在此。【不过此处不会检查serialVersionUID】==

==方法writeObject处理对象的序列化。如果声明该方法，它将会被ObjectOutputStream调用而不是默认的序列化进程。如果你是第一次看见它，你会很惊奇尽管它们被外部类调用但事实上这是两个private的方法。并且它们既不存在于java.lang.Object，也没有在Serializable中声明。那么ObjectOutputStream如何使用它们的呢？这个吗，ObjectOutputStream使用了反射来寻找是否声明了这两个方法。因为ObjectOutputStream使用**getPrivateMethod**，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。== 

　　==在两个方法的开始处，你会发现调用了defaultWriteObject()和defaultReadObject()。它们做的是默认的序列化进程，就像写/读所有的non-transient和 non-static字段(但他们不会去做serialVersionUID的检查).通常说来，所有我们想要自己处理的字段都应该声明为transient。==

　1.==Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;== 

　　2.==Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。== 

**==我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。==**

==无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象。==

**==transient关键字是和Serializable默认序列化行为联系在一起的，同时也是和 ObjectOutputStream out.defaultWriteObject()，ObjectInputStream in.defaultReadObject() 这两个方法联系在一起的。在进行默认序列化操作，以及调用out.defaultWriteObject()和in.defaultReadObject()这两个方法进行序列化操作的时候，标注transient的变量会被序列化操作所忽略。除Serializable之外，transient关键字在其他地方不会起到任何作用。==**

**==Externalizable的优先级比Serializable的优先级要高。假如，某个类同时实现了两个接口，那么在序列化的时候只会考虑和Externalizable接口相关的性质，而不会考虑和Serializable相关的性质==。**



==序列化会通过反射调用无参数的构造方法创建一个新的对象。====如果实现了serializable 或者 externalizable接口的类中包含`readResolve`==，==那么这个方法会在反序列化完成之后被调用，实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象。==

==**writeObject:** 用来处理对象的序列化，如果声明该方法，它会被ObjectOutputStream调用，而不是默认的序列化进程；== 
==**readObject:** 和writeObject相对应，用来处理对象的反序列化。== 
==ObjectOutputStream使用**反射getPrivateMethod**来寻找默认序列化的类是否声明了这两个方法，所以这两个方法必须声明为private提供ObjectOutputStream使用。虚拟机会先试图调用对象里的writeObject, readObject方法，进行用户自定义序列化和反序列化，若没有这样的方法，就会使用默认的ObjectOutputSteam的defaultWriteObject及ObjectInputStream里的defaultReadObject方法。==



- 说说反射的用途及实现

- 说说自定义注解的场景及实现

- HTTP请求的GET与POST方式的区别

- Session与Cookie区别

- 列出自己常用的JDK包

- MVC设计思想

  

### **1.2、Java常见集合**

==迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历,Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。 Set 和List 都继承了Conllection。==

 Collection接口的方法（8个）：

```java
boolean add(Object o)      ：向集合中加入一个对象的引用   

void clear()：删除集合中所有的对象，即不再持有这些对象的引用   
  
boolean isEmpty()    ：判断集合是否为空   
   
boolean contains(Object o) ： 判断集合中是否持有特定对象的引用   

Iterartor iterator()  ：返回一个Iterator对象，可以用来遍历集合中的元素   
   
boolean remove(Object o) ：从集合中删除一个对象的引用   
   
int size()       ：返回集合中元素的数目   
   
Object[] toArray()    ： 返回一个数组，该数组中包括集合中的所有元素 </span> 
```

![1531329148160](D:\workspace\Github\node\瑞秋\LMS\assets\1531329148160.png)

### Iterator接口声明了如下方法：

```java
hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true   
  
next() ：返回下一个元素   
  
remove()：从集合中删除上一个有next()方法返回的元素。 
```

#### List 和 Set 区别

Set集合中的对象不按特定的方式排序，存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。 对Set的构造函数，传入的Collection参数不能包含重复的元素。

**HashSet是Set接口的典型实现，==HashSet使用HASH算法来存储集合中的元素（底层实现为HashMap），==因此具有良好的存取和查找性能。**
     值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等

 ==**LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。**==
　　当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。

==List的特征是其元素以线性方式存储，集合中可以存放重复对象。==

- Set和hashCode以及equals方法的联系
- List 和 Map 区别
- Arraylist 与 LinkedList 区别
- ArrayList 与 Vector 区别
- HashMap 和 Hashtable 的区别
- HashSet 和 HashMap 区别

   **HashSet是Set接口的典型实现，==HashSet使用HASH算法来存储集合中的元素（底层实现为HashMap），==因此具有良好的存取和查找性能。**
     值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等



- HashMap 和 ConcurrentHashMap 的区别
- HashMap 的工作原理及代码实现，什么时候用到红黑树
- 多线程情况下HashMap死循环的问题
- HashMap出现Hash DOS攻击的问题
- ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数
- 手写简单的HashMap
- 看过那些Java集合类的源码

**1.3、进程和线程**

- 线程和进程的概念、并行和并发的概念
- 创建线程的方式及实现
- 进程间通信的方式

### 说说 CountDownLatch、CyclicBarrier 原理和区别、Phaser

**CountDownLatch** : **一个线程**(或者多个)， 等待另外**N个线程**完成**某个事情**之后才能执行。   

**CyclicBarrier**  : **N个线程**相互等待，任何一个线程完成之前，所有的线程都必须等待。 

CountDownLatch经常用于监听某些初始化操作，等初始化执行完毕后，再通知主线程继续工作。

CyclicBarrier和CountDownLatch 都位于java.util.concurrent 这个包下

| CountDownLatch                                               | CyclicBarrier                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 减计数方式                                                   | 加计数方式                                                   |
| 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
| 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用                                                 | 可重复利用                                                   |

## CountDownLatch定义：

一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行

下面我们来看下CountDownLatch的使用方法：

```java 
public class CountDownLatchTest {
 
	public static void main(String[] args) {
		//实例化一个CountDownLatch对象
		final CountDownLatch countDownLatch = new CountDownLatch(2);
		//创建一个线程t1
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					System.out.println("进入线程t1  等待其他线程处理完成……");
					countDownLatch.await();
					System.out.println("t1线程继续执行……");
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		},"t1").start();
		//创建一个线程t2
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					System.out.println("进入线程t3进行初始化操作……");
					Thread.sleep(2000);
					System.out.println("t3线程执行完毕。。。");
					countDownLatch.countDown();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		},"t2").start();
		//创建一个线程t3
		new Thread(new Runnable() {
			@Override
			public void run() {
				try {
					System.out.println("进入线程t2进行初始化操作……");
					Thread.sleep(4000);
					System.out.println("t2线程执行完毕。。。");
					countDownLatch.countDown();
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		},"t3").start();
	}
}

```

执行结果如下：

进入线程t1  等待其他线程处理完成……
进入线程t3进行初始化操作……
进入线程t2进行初始化操作……
t3线程执行完毕。。。
t2线程执行完毕。。。
t1线程继续执行……

#### CountDownLatch的使用场景：

在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。 这个时候就可以使用CountDownLatch。CountDownLatch最重要的方法是countDown()和await()，前者主要是倒数一次，后者是等待倒数到0，如果没有到达0，就只有阻塞等待了。

#### 二.CyclicBarrier的使用

假设有一个场景，每个线程代表一个跑步的运动员，当运动员都准备好之后，才一起出发，只要有一个运动员还没有准备好，所有线程就一起等待。

#### CyclicBarrier的定义(来自百度)：

CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。

下面我们来看CyclicBarrier 的使用小Demo：

```
public class CyclicBarrireTest {
 
	public static void main(String[] args) {
		CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
		ExecutorService executorService = Executors.newFixedThreadPool(3);
		try {
			executorService.execute(new Runner(cyclicBarrier, "张三"));
			executorService.execute(new Runner(cyclicBarrier, "李四"));
			executorService.execute(new Runner(cyclicBarrier, "王五"));
		} finally {
			executorService.shutdown();
		}
	}
	
	static class Runner implements Runnable{
		private String name;
		private CyclicBarrier cyclicBarrier;
		public Runner(CyclicBarrier cyclicBarrier,String name) {
			this.name = name;
			this.cyclicBarrier=cyclicBarrier;
		}
		
		@Override
		public void run() {
			try {
				Thread.sleep(1000*new Random().nextInt(5));
				System.out.println(Thread.currentThread().getName() +"已经准备好");
					cyclicBarrier.await();
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (BrokenBarrierException e) {
				e.printStackTrace();
			}
			System.err.println(Thread.currentThread().getName() +"出发！！");
		}
		
	}
}

```

pool-1-thread-1已经准备好

pool-1-thread-3已经准备好 

pool-1-thread-2已经准备好 

pool-1-thread-2出发！！ 

pool-1-thread-1出发！！ 

pool-1-thread-3出发！！ 

CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。



#### 三.cyclicBarrier和CountDownLatch的区别

1、CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。

2、cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！

3、CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。

4,、CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。

CountDownLatch 允许一个或多个线程等待一些特定的操作完成，而这些操作是在其它的线程中进行的，也就是说会出现 **等待的线程** 和 **被等的线程** 这样分明的角色；

CountDownLatch 构造函数中有一个 count 参数，表示有多少个线程需要被等待，对这个变量的修改是在其它线程中调用 countDown 方法，每一个不同的线程调用一次 countDown 方法就表示有一个被等待的线程到达，count 变为 0 时，latch（门闩）就会被打开，处于等待状态的那些线程接着可以执行；

CountDownLatch 是一次性使用的，也就是说latch门闩只能只用一次，一旦latch门闩被打开就不能再次关闭，将会一直保持打开状态，因此 CountDownLatch 类也没有为 count 变量提供 set 的方法；

# CountDownLatch

一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 

其机制是：

　　当多个（具体数量等于初始化CountDownLatch时的count参数的值）线程都达到了预期状态或完成预期工作时触发事件，其他线程可以等待这个事件来触发自己的后续工作。这里需要注意的是，等待的线程可以是多个，即CountDownLatch是可以唤醒多个等待的线程的。达到自己预期状态的线程会调用CountDownLatch的countDown方法，而等待的线程会调用CountDownLatch的await方法。

CountDownLatch 很适合用来将一个任务分为n个独立的部分，等这些部分都完成后继续接下来的任务，CountDownLatch 只能出发一次，计数值不能被重置。

## 流程图

![img](https://images2017.cnblogs.com/blog/400827/201709/400827-20170928135838278-808448367.png)

 

如上图所示，当7个线程都完成latch.countDown调用后，最下面那条线程会从latch.await返回，继续执行后面的代码

## 函数列表

- CountDownLatch(int count) ：构造一个用给定计数初始化的 CountDownLatch。

- void await()：使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。

- boolean await(long timeout, TimeUnit unit) 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。

- void countDown() 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。

## 实现原理

　　CountDownLatch是通过“共享锁”实现的。在创建CountDownLatch中时，会传递一个int类型参数count，该参数是“锁计数器”的初始状态，表示该“共享锁”最多能被count给线程同时获取。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取“共享锁”进而继续运行。而“共享锁”可用的条件，就是“锁计数器”的值为0！而“锁计数器”的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，才将“锁计数器”-1；通过这种方式，必须有count个线程调用countDown()之后，“锁计数器”才为0，而前面提到的等待线程才能继续运行！ 

 

## 实例

 　　我们来看一个具体的例子。假设我们使用一台多核的机器对一组数据进行排序，那么我们可以把这组数据分到不同线程中进行排序，然后合并；可以利用线程池来管理多线程；可以将CountDownLatch用作各个分组数据都排好序的通知。下面是代码片段：

先看主线程

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
int count = 10;
final CountDownLatch latch = new CountDownLatch(count);
int[] datas = new int[10204];
int step = datas.length / count;
for (int i=0; i < count; i++) {
    int start = i * step;
    int end = (i+1) * step;
    if (i == count - 1) end = datas.length;
    threadpool.execute(new MyRunnable(latch, datas, start, end));
}
latch.await();
//合并数据
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

我们再看一下具体任务的代码，即MyRunnable的run方法的实现：

```
public void run() {
      //数据排序
     latch.countDown(); 
}
```

 

# CyclicBarrier

可以协同多个线程，让多个线程在这个屏障前等待，直到所有线程都达到了这个屏障时，再一起继续执行后面的动作。

CyclicBarrier适用于多个线程有固定的多步需要执行，线程间互相等待，当都执行完了，再一起执行下一步。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。

 

## 流程图

![img](https://images2017.cnblogs.com/blog/400827/201709/400827-20170928140524809-537975110.png)

 上图中的7个线程各有一个barrier.await,那么任何一个线程在执行到barrier.await时就会进入阻塞等待状态，直到7个线程都到了barrier.await时才会同时从await返回，继续后面的工作。此外如果在构造CyclicBarrier时设置了一个Runnable实现，那么最后一个到barrier.await的线程会执行这个Runnable的run方法，以完成一些预设的工作。

 

注意比较[CountDownLatch](http://www.cnblogs.com/skywang12345/p/3533887.html)和[CyclicBarrier](http://www.cnblogs.com/skywang12345/p/3533995.html)：

　　(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。

　　(02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。

CountDownLatch 适用于一组线程和另一个主线程之间的工作协作。一个主线程等待一组工作线程的任务完毕才继续它的执行是使用 CountDownLatch 的主要场景；CyclicBarrier 用于一组或几组线程，比如一组线程需要在一个时间点上达成一致，例如同时开始一个工作。另外，CyclicBarrier 的循环特性和构造函数所接受的 Runnable 参数也是 CountDownLatch 所不具备的。

 

 

|          | CountDownLatch                                               | CyclicBarrier                                                |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 适用场景 | 主线程等待其他工作线程结束                                   | 多个线程相互等待，直到所有线程都达到一个障碍点Barrier        |
| 主要方法 | CountDownLatch(int count) 主线程调用：初始化计数 await() 主线程调用 ： 阻塞，直到等待计数为0时解除阻塞  countDown() 工作线程调用 ： 计数减1 | CyclicBarrier(int parties , Runnnable barrierAction) : 初始化参与者数量和障碍点执行Action，action可选，由主线程初始化 await() : 由工作线程调用，每被调用一次，计数便会减少1，并阻塞住当前线程 ， 直到所有线程都达到障碍点 |
| 等待结束 | 各线程之间不再相互影响， 可以继续做自己的事情， 不再执行下一个工作目标。 | 在障碍点到达后， 允许所有线程继续执行，到达下一个目标后，可以恢复使用CyclicBarrier， barrier 在释放等待线程后可以重用 |
| 异常     |                                                              | 如果其中一个线程由于中断、错误、或者超时导致永久离开障碍点，其他线程也将抛出异常。 |

# 说说 Semaphore 原理

Semaphore 信号量对象管理的信号就像令牌，构造时传入个数，总数就是控制并发的数量。我们需要控制并发的代码，执行前先获取信号(通过acquire获取信号许可)，执行后归还信号(通过release归还信号许可)。每次acquire成功返回后，Semaphore可用的信号量就会减少一个，如果没有可用的信号，acquire调用就会阻塞，等待有release调用释放信号后，acquire才会得到信号并返回。

如果Semaphore管理的信号量为1个，那么就退化到互斥锁了；如果多于一个信号量，则主要用于控制并发数。与通过控制线程数来控制并发数的方式相比，通过Semaphore来控制并发数可以控制得更加细粒度，因为真正被控制最大并发的代码放到acquire和release之间就行了。

　　Semaphore类位于java.util.concurrent包下，它提供了2个构造器：

```
public Semaphore(int permits) {          //参数permits表示许可数目，即同时可以允许多少线程进行访问
    sync = new NonfairSync(permits);
}
public Semaphore(int permits, boolean fair) {    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
}
```

## 实例

 　　例如我们需要控制远程方法的并发量，超过并发量的方法就等待有其他方法执行返回后再执行，那么其代码如下：

```
semaphore.acquire();
try {
    //调用远程通信的方法
}
finally {
    semaphore.release();
}
```



下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：

　　acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。

　　release()用来释放许可。注意，在释放许可之前，必须先获获得许可。

　　这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：

```java
public boolean tryAcquire() { };    //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
```

另外还可以通过availablePermits()方法得到可用的许可数目。

下面通过一个例子来看一下Semaphore的具体使用：

假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：

```java
public class Test {
    public static void main(String[] args) {
        int N = 8;            //工人数
        Semaphore semaphore = new Semaphore(5); //机器数目
        for(int i=0;i<N;i++)
            new Worker(i,semaphore).start();
    }
     
    static class Worker extends Thread{
        private int num;
        private Semaphore semaphore;
        public Worker(int num,Semaphore semaphore){
            this.num = num;
            this.semaphore = semaphore;
        }
         
        @Override
        public void run() {
            try {
                semaphore.acquire();
                System.out.println("工人"+this.num+"占用一个机器在生产...");
                Thread.sleep(2000);
                System.out.println("工人"+this.num+"释放出机器");
                semaphore.release();           
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
工人0占用一个机器在生产...
工人1占用一个机器在生产...
工人2占用一个机器在生产...
工人4占用一个机器在生产...
工人5占用一个机器在生产...
工人0释放出机器
工人2释放出机器
工人3占用一个机器在生产...
工人7占用一个机器在生产...
工人4释放出机器
工人5释放出机器
工人1释放出机器
工人6占用一个机器在生产...
工人3释放出机器
工人7释放出机器
工人6释放出机器
```



### 说说 Exchanger 原理

从官方的javadoc可以知道，当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。 

在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种：

1. 如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。
2. 如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。
3. 如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。

- ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理



# 线程池的实现原理

当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池 
的主要处理流程，处理流程图所示。 
从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。 
1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作 
线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。 
2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这 
个工作队列里。如果工作队列满了，则进入下个流程。 
3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程 
来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 



向线程池提交任务的两种方式：

1）通过execute()方法

这种方式提交没有返回值，也就不能判断任务是否被线程池执行成功。

2）通过submit()方法

使用submit 方法来提交任务，**它会返回一个Future对象，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成**，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。

线程池的关闭：

• shutdown()：不会立即终止线程池，而是**再也不会接受新的任务**，**要等所有任务缓存队列中的任务都执行完后才终止**
• shutdownNow()：**立即终止线程池，再也不会接受新的任务，并尝试打断正在执行的任务**，并且清空任务缓存队列，返回尚未执行的任务

对于原理，在 Java 中，有几个接口，类 值得我们关注：

- Executor
- ExecutorService
- AbstractExecutorService
- ThreadPoolExecutor

## Executor

```
public interface Executor {
    void execute(Runnable command);
}
```

Executor 接口只有一个 方法，execute，并且需要 传入一个 Runnable 类型的参数。**那么它的作用自然是 具体的执行参数传入的任务。**

## ExecutorService

ExecutorService 接口继承了 Executor，

Ps：execute 和 submit 区别：

- **submit 有返回值，execute 没有返回值。** 所以说可以根据任务有无返回值选择对应的方法。
- **submit 方便异常的处理。** 如果任务可能会抛出异常，而且希望外面的调用者能够感知这些异常，那么就需要调用 submit 方法，通过捕获 Future.get 抛出的异常。

## AbstractExecutorService

AbstractExecutorService 是一个抽象类，**主要完成了 对 submit 方法，invokeAll 方法 的实现。** 但是其实它的内部还是调用了 execute 方法，例如：

```
public Future submit(Runnable task) {
    if (task == null) throw new NullPointerException();
        RunnableFuture ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
```

## ThreadPoolExecutor

ThreadPoolExecutor 继承了 AbstractExecutorService，**并且实现了最重要的 execute 方法**，是我们主要需要研究的类。另外，整个线程池是如何实现的呢？

在该类中，有两个成员变量 非常的重要：

```
private final HashSet workers = new HashSet();
private final BlockingQueue workQueue;
```

对于 workers 变量，主要存在了线程对象 Worker，Worker 实现了 Runnable 接口。而对于 workQueue 变量，主要存放了需要执行的任务。 这样其实可以猜到， **整个线程池的实现原理应该是从workQueue 中不断的取出需要执行的任务，放在 workers 中进行处理。**

另外，当线程池中的线程用完了之后，多余的任务会等待，那么这个等待的过程是 怎么实现的呢？ 其实如果熟悉 BlockingQueue，那么就会马上知道，**是利用了 BlockingQueue 的take 方法进行处理**。



## 总结

现在就可以知道，大致的线程池实现原理：

首先，各自存放线程和任务，其中，任务带有阻塞。

```
private final HashSet workers = new HashSet();
private final BlockingQueue workQueue;
```

然后，在 execute 方法中 进行 addWorker(command，true)，也就是创建一个线程，把任务放进去执行；或者是直接把任务放入到任务队列中。

接着 如果是 addWorker，那么就会 new Worker(task) -》调用其中 run() 方法，在Worker 的run() 方法中，调用 runWorker(this); 方法 -》在该方法中就会具体执行我们的任务 task.run(); 同时这个 runWorker方法相当于是个死循环，正常情况下就会一直取出 任务队列中的任务来执行，这就保证了线程 不会销毁。

所以，这也是为什么常说的线程池可以避免线程的频繁创建和 销毁带来的性能消耗。

------

线程池：可以理解为缓冲区，由于频繁的创建销毁线程会带来一定的成本，可以预先创建但不立即销毁，以共享方式为别人提供服务，一来可以提供效率，再者可以控制线程无线扩张。合理利用线程池能够带来三个好处：

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

但是要做到合理的利用线程池，必须对其原理了如指掌。



![](D:\workspace\Github\node\瑞秋\answer\assets\1506308400666NssJxY.png)

ThreadPoolExecutor的构造方法 

- **corePoolSize**：线程池中的核心线程数；
- **maximumPoolSize**：线程池最大线程数，它表示在线程池中最多能创建多少个线程；
- **keepAliveTime**：线程池中**非核心线程闲置超时时长**（准确来说应该是没有任务执行时的回收时间，后面会分析）；
  - 一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉
  - 如果设置`allowCoreThreadTimeOut(boolean value)`，则会作用于核心线程

- **TimeUnit**：时间单位。可选的单位有分钟（MINUTES），秒（SECONDS），毫秒(MILLISECONDS) 等；

- workQueue：任务的阻塞队列，缓存将要执行的Runnable任务，由各线程轮询该任务队列获取任务执行。可以选择以下几个阻塞队列。

  - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
  - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法`Executors.newFixedThreadPool()`使用了这个队列。
  - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法`Executors.newCachedThreadPool`使用了这个队列。
  - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。

- **ThreadFactory**：线程创建的工厂。可以进行一些属性设置，比如线程名，优先级等等，有默认实现。

- RejectedExecutionHandler

  ：任务拒绝策略，当运行线程数已达到maximumPoolSize，队列也已经装满时会调用该参数拒绝任务，默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。

  - AbortPolicy：直接抛出异常。
  - CallerRunsPolicy：只用调用者所在线程来运行任务。
  - DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
  - DiscardPolicy：不处理，丢弃掉。
  - 当然也可以根据应用场景需要来实现`RejectedExecutionHandler`接口自定义策略。如记录日志或持久化不能处理的任务。

## 几种排队的策略

- 直接提交。缓冲队列采用 SynchronousQueue，它将任务直接交给线程处理而不保持它们。如果不存在可用于立即运行任务的线程（即线程池中的线程都在工作），则试图把任务加入缓冲队列将会失败，因此会构造一个新的线程来处理新添加的任务，并将其加入到线程池中。直接提交通常要求无界 maximumPoolSizes（Integer.MAX_VALUE） 以避免拒绝新提交的任务。newCachedThreadPool 采用的便是这种策略。
- 无界队列。使用无界队列（典型的便是采用预定义容量的 LinkedBlockingQueue，理论上是该缓冲队列可以对无限多的任务排队）将导致在所有 corePoolSize 线程都工作的情况下将新任务加入到缓冲队列中。这样，创建的线程就不会超过 corePoolSize，也因此，maximumPoolSize 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。newFixedThreadPool采用的便是这种策略。
- 有界队列。当使用有限的 maximumPoolSizes 时，有界队列（一般缓冲队列使用 ArrayBlockingQueue，并制定队列的最大长度）有助于防止资源耗尽，但是可能较难调整和控制，队列大小和最大池大小需要相互折衷，需要设定合理的参数。

### ThreadPoolExecutor的状态变量

其中ctl是ThreadPoolExecutor的同步状态变量。

`workerCountOf()`方法取得当前线程池的线程数量，算法是将ctl的值取低29位。

`runStateOf()`方法取得线程池的状态，算法是将ctl的值取高3位:

1. **RUNNING** ：111 表示正在运行，能接受新提交的任务，并且也能处理阻塞队列中的任务；

2. **SHUTDOWN**：000 表示拒绝接收新的任务，关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；

3. **STOP**：001 表示拒绝接收新的任务并且不再处理任务队列中剩余的任务，并且中断正在执行的任务。不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；

4. **TIDYING**：010 表示所有线程已停止，准备执行terminated()方法。如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。

5. **TERMINATED**：011 表示已执行完terminated()方法。在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。

   进入TERMINATED的条件如下：

   - 线程池不是RUNNING状态；
   - 线程池状态不是TIDYING状态或TERMINATED状态；
   - 如果线程池状态是SHUTDOWN并且workerQueue为空；
   - workerCount为0；
   - 设置TIDYING状态成功。

下图为线程池的状态转换过程：

![img](https://user-gold-cdn.xitu.io/2017/4/22/77c2251dacf9e26fe1ba1e1e54e62a65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



当我们向线程池提交任务时，通常使用`execute()`方法，接下来就先从该方法开始分析。

### execute()方法

在分析execute代码之前，需要先说明下，我们都知道线程池是维护了一批线程来处理用户提交的任务，达到线程复用的目的，**线程池维护的这批线程被封装成了Worker**。

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * clt记录着runState和workerCount
     */
    int c = ctl.get();
    /*
     * workerCountOf方法取出低29位的值，表示当前活动的线程数；
     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；
     * 并把任务添加到该线程中。
     */
    if (workerCountOf(c) < corePoolSize) {
        /*
         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；
         * 如果为true，根据corePoolSize来判断；
         * 如果为false，则根据maximumPoolSize来判断
         */
        if (addWorker(command, true))
            return;
        /*
         * 如果添加失败，则重新获取ctl值
         */
        c = ctl.get();
    }
    /*
     * 如果当前线程池是运行状态并且任务添加到队列成功
     */
    if (isRunning(c) && workQueue.offer(command)) {
        // 重新获取ctl值
        int recheck = ctl.get();
        // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，
        // 这时需要移除该command
        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回
        if (! isRunning(recheck) && remove(command))
            reject(command);
        /*
         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法
         * 这里传入的参数表示：
         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；
         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；
         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。
         */
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    /*
     * 如果执行到这里，有两种情况：
     * 1. 线程池已经不是RUNNING状态；
     * 2. 线程池是RUNNING状态，但workerCount >= corePoolSize并且workQueue已满。
     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；
     * 如果失败则拒绝该任务
     */
    else if (!addWorker(command, false))
        reject(command);
}
```



以上代码对应了三种情况:

1. 线程池的线程数量小于corePoolSize核心线程数量，开启核心线程执行任务。

2. 线程池的线程数量不小于corePoolSize核心线程数量，或者开启核心线程失败，尝试将任务以非阻塞的方式添加到任务队列。

3. 任务队列已满导致添加任务失败，开启新的非核心线程执行任务。

回顾**FixedThreadPool**，因为它配置的corePoolSize与maximumPoolSize相等，所以不会执行到情况3，并且因为workQueue为默认的LinkedBlockingQueue，其长度为`Integer.MAX_VALUE`，几乎不可能出现任务无法被添加到workQueue的情况，所以FixedThreadPool的所有任务执行在核心线程中。

而**CachedThreadPool**的corePoolSize为0，表示它不会执行到情况1，因为它的maximumPoolSize为`Integer.MAX_VALUE`，所以几乎没有线程数量上限，因为它的workQueue为SynchronousQueue，所以当线程池里没有闲置的线程SynchronousQueue就会添加任务失败，因此会执行到情况3添加新的线程执行任务。

`addWorker`这个方法先尝试在线程池运行状态为`RUNNING`并且线程数量未达上限的情况下通过CAS操作将线程池数量+1，接着在ReentrantLock同步锁的同步保证下判断线程池为运行状态，然后把Worker添加到HashSet workers中。如果添加成功则执行Worker的内部线程。addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务(注意一下这里的`t.start()`这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。 )，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下： 

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        // 获取运行状态
        int rs = runStateOf(c);

        /*
         * 这个if判断
         * 如果rs >= SHUTDOWN，则表示此时不再接收新任务；
         * 接着判断以下3个条件，只要有1个不满足，则返回false：
         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务
         * 2. firsTask为空
         * 3. 阻塞队列不为空
         * 
         * 首先考虑rs == SHUTDOWN的情况
         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；
         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，
         * 因为队列中已经没有任务了，不需要再添加线程了
         */
        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            // 获取线程数
            int wc = workerCountOf(c);
            // 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；
            // 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，
            // 如果为false则根据maximumPoolSize来比较。
            // 
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 尝试增加workerCount，如果成功，则跳出第一个for循环
            if (compareAndIncrementWorkerCount(c))
                break retry;
            // 如果增加workerCount失败，则重新获取ctl的值
            c = ctl.get();  // Re-read ctl
            // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 根据firstTask来创建Worker对象
        w = new Worker(firstTask);
        // 每一个Worker对象都会创建一个线程
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
                // rs < SHUTDOWN表示是RUNNING状态；
                // 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。
                // 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // workers是一个HashSet
                    workers.add(w);
                    int s = workers.size();
                    // largestPoolSize记录着线程池中出现过的最大线程数量
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```



Worker构造方法指定了第一个要执行的任务firstTask，并通过线程池的线程工厂创建线程。可以发现这个线程的参数为this，即Worker对象，因为Worker实现了Runnable因此可以被当成任务执行，执行的即Worker实现的run方法 ,runWorker()方法

因为Worker为ThreadPoolExecutor的内部类，因此runWorker方法实际是ThreadPoolExecutor定义的.

这个方法是线程池复用线程的核心代码，注意Worker继承了`AbstractQueuedSynchronizer`，在执行每个任务前通过lock方法加锁，执行完后通过unlock方法解锁，这种机制用来防止运行中的任务被中断。在执行任务时先尝试获取firstTask，即构造方法传入的Runnable对象，然后尝试从`getTask`方法中获取任务队列中的任务。在任务执行前还要再次判断线程池是否已经处于STOP状态或者线程被中断。

在runWorker中，每一个Worker在`getTask()`成功之后都要获取Worker的锁之后运行，也就是说运行中的Worker不会中断。因为核心线程一般在空闲的时候会一直阻塞在获取Task上，也只有中断才可能导致其退出。这些阻塞着的Worker就是空闲的线程（当然，非核心线程阻塞之后也是空闲线程）。如果设置了keepAliveTime>0，那非核心线程会在空闲状态下等待keepAliveTime之后销毁，直到最终的线程数量等于corePoolSize

woker线程的执行流程就是首先执行初始化时分配给的任务，执行完成以后会尝试从阻塞队列中获取可执行的任务，如果指定时间内仍然没有任务可以执行，则进入销毁逻辑调用`processWorkerExit()`方法。
**注：这里只会回收corePoolSize与maximumPoolSize直接的那部分woker**

Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。

在调用构造方法时，需要把任务传入，这里通过`getThreadFactory().newThread(this);`来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。

Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：

1. lock方法一旦获取了独占锁，表示当前线程正在执行任务中；
2. 如果正在执行任务，则不应该中断线程；
3. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；
4. 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；
5. 之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。

所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。

此外，在构造方法中执行了`setState(-1);`，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：

```
protected boolean tryAcquire(int unused) {
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}
```

tryAcquire方法是根据state是否是0来判断的，所以，`setState(-1);`将state设置为-1是为了禁止在执行任务前对线程进行中断。

正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0.

### runWorker方法

在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的代码如下：

```
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    // 获取第一个任务
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 允许中断
    w.unlock(); // allow interrupts
    // 是否因为异常退出循环
    boolean completedAbruptly = true;
    try {
        // 如果task为空，则通过getTask来获取任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

这里说明一下第一个if判断，目的是：

- 如果线程池正在停止，那么要保证当前线程是中断状态；
- 如果不是的话，则要保证当前线程不是中断状态；

这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：

> 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。

STOP状态要中断线程池中的所有线程，而这里使用`Thread.interrupted()`来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。

总结一下runWorker方法的执行过程：

1. while循环不断地通过getTask()方法获取任务；
2. getTask()方法从阻塞队列中取任务；
3. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；
4. 调用`task.run()`执行任务；
5. 如果task为null则跳出循环，执行processWorkerExit()方法；
6. runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。

这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。

completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。

### getTask方法

getTask方法用来从阻塞队列中取任务，代码如下：

```
private Runnable getTask() {
    // timeOut变量的值表示上次从阻塞队列中取任务时是否超时
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        /*
         * 如果线程池状态rs >= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：
         * 1. rs >= STOP，线程池是否正在stop；
         * 2. 阻塞队列是否为空。
         * 如果以上条件满足，则将workerCount减1并返回null。
         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。
         */
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        // timed变量用于判断是否需要进行超时控制。
        // allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；
        // wc > corePoolSize，表示当前线程池中的线程数量大于核心线程数量；
        // 对于超过核心线程数量的这些线程，需要进行超时控制
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        /*
         * wc > maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；
         * timed && timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时
         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；
         * 如果减1失败，则返回重试。
         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。
         */
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            /*
             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；
             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。
             * 
             */
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // 如果 r == null，说明已经超时，timedOut设置为true
            timedOut = true;
        } catch (InterruptedException retry) {
            // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试
            timedOut = false;
        }
    }
}
```

这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。

什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。

getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。

### getTask()方法

这里`getTask()`方法是要重点说明的，它的实现跟我们构造参数keepAliveTime存活时间有关。我们都知道keepAliveTime代表了线程池中的线程（即woker线程）的存活时间，如果到期则回收woker线程，这个逻辑的实现就在getTask中。

`getTask()`方法就是去阻塞队列中取任务，用户设置的存活时间，就是从这个阻塞队列中取任务等待的最大时间，如果getTask返回null，意思就是woker等待了指定时间仍然没有取到任务，此时就会跳过循环体，进入woker线程的销毁逻辑。

这个`getTask()`方法通过一个循环不断轮询任务队列有没有任务到来，首先判断线程池是否处于正常运行状态，根据超时配置有两种方法取出任务：

1. BlockingQueue.poll 阻塞指定的时间尝试获取任务，如果超过指定的时间还未获取到任务就返回null。
2. BlockingQueue.take 这种方法会在取到任务前一直阻塞。

FixedThreadPool使用的是take方法，所以会线程会一直阻塞等待任务。CachedThreadPool使用的是poll方法，也就是说CachedThreadPool中的线程如果在60秒内未获取到队列中的任务就会被终止。

到此ThreadPoolExecutor是怎么执行Runnable任务的分析结束。

### processWorkerExit方法

```
private void processWorkerExit(Worker w, boolean completedAbruptly) {
    // 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；
    // 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。  
    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        //统计完成的任务数
        completedTaskCount += w.completedTasks;
        // 从workers中移除，也就表示着从线程池中移除了一个工作线程
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    // 根据线程池状态进行判断是否结束线程池
    tryTerminate();

    int c = ctl.get();
    /*
     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；
     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；
     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。
     */
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 && ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) >= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
```

至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：

![img](https://user-gold-cdn.xitu.io/2017/4/22/fb66e616aa6da061f92d0b4eebb64b7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### tryTerminate方法

tryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：

```
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        /*
         * 当前线程池的状态为以下几种情况时，直接返回：
         * 1. RUNNING，因为还在运行中，不能停止；
         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；
         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；
         */
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
        // 如果线程数量不为0，则中断一个空闲的工作线程，并返回
        if (workerCountOf(c) != 0) { // Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // terminated方法默认什么都不做，留给子类实现
                    terminated();
                } finally {
                    // 设置状态为TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
```

### shutdown方法

shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。

```
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 安全策略判断
        checkShutdownAccess();
        // 切换状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试结束线程池
    tryTerminate();
}
```

这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？

下面仔细分析一下：

- 在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；
- shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；
- 在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用`workQueue.take()`进行阻塞；
- 如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了`workQueue.take()`后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；
- 由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；
- 解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用`workQueue.take()`时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；
- 但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；
- 所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。

下面就来分析一下interruptIdleWorkers方法。

### interruptIdleWorkers方法

```
private void interruptIdleWorkers() {
    interruptIdleWorkers(false);
}

private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。

为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。

### shutdownNow方法

```
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        // 中断所有工作线程，无论是否空闲
        interruptWorkers();
        // 取出队列中没有被执行的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```

shutdownNow方法与shutdown方法类似，不同的地方在于：

1. 设置状态为STOP；
2. 中断所有工作线程，无论是否是空闲的；
3. 取出阻塞队列中没有被执行的任务并返回。

shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。

## 线程池的监控

通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用

- **getTaskCount**：线程池已经执行的和未执行的任务总数；
- **getCompletedTaskCount**：线程池已完成的任务数量，该值小于等于taskCount；
- **getLargestPoolSize**：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；
- **getPoolSize**：线程池当前的线程数量；
- **getActiveCount**：当前线程池中正在执行任务的线程数量。

通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。

## 总结

本文比较详细的分析了线程池的工作流程，总体来说有如下几个内容：

- 分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；
- 这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。
- 介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；
- 在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断工作线程以及为什么每一个worker都需要lock。

在向线程池提交任务时，除了execute方法，还有一个submit方法，submit方法会返回一个Future对象用于获取返回值，有关Future和Callable请自行了解一下相关的文章，这里就不介绍了。

------



## 常用的几个线程池工厂方法

`Executors`是java.util.concurrent包下的一个线程池工厂，负责创建常用的线程池，主要有如下几种:

### newFixedThreadPool

一个固定线程数量的线程池:

```
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    //corePoolSize跟maximumPoolSize值一样，同时传入一个无界阻塞队列
    //根据上面分析的woker回收逻辑，该线程池的线程会维持在指定线程数，不会进行回收
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

定长线程池：

1. 可控制线程最大并发数（同时执行的线程数）
2. 超出的线程会在队列中等待

### newCachedThreadPool

不固定线程数量，且支持最大为`Integer.MAX_VALUE`的线程数量:

```
public static ExecutorService newCachedThreadPool() {
    //这个线程池corePoolSize为0，maximumPoolSize为Integer.MAX_VALUE
    //意思也就是说来一个任务就创建一个woker，回收时间是60s
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

可缓存线程池：

1. 线程数无限制
2. 有空闲线程则复用空闲线程，若无空闲线程则新建线程
3. 一定程序减少频繁创建/销毁线程，减少系统开销

### newSingleThreadExecutor

可以理解为线程数量为1的FixedThreadPool:

```
public static ExecutorService newSingleThreadExecutor() {
    //线程池中只有一个线程进行任务执行，其他的都放入阻塞队列
    //外面包装的FinalizableDelegatedExecutorService类实现了finalize方法，在JVM垃圾回收的时候会关闭线程池
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

单线程化的线程池：

1. 有且仅有一个工作线程执行任务
2. 所有任务按照指定顺序执行，即遵循队列的入队出队规则

### newScheduledThreadPool

支持定时以指定周期循环执行任务:

```
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
```

其中前三种线程池是ThreadPoolExecutor不同配置的实例，最后一种是ScheduledThreadPoolExecutor的实例。

最后再说说初始化线程池时线程数的选择：

- 如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。
- 如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。

上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。

## 线程池技术适用范围

线程池的应用范围：

1. 需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。
2. 对性能要求苛刻的应用，比如要求服务器迅速相应客户请求。
3. 接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，并出现”OutOfMemory”的错误。

## 总结

到此无论是主动提交任务给新建线程执行，还是已有的线程自己到阻塞队列取任务执行，都应该清楚了然了。
从数据结构的角度来看，线程池主要使用了阻塞队列（BlockingQueue）和HashSet集合构成。
从任务提交的流程角度来看，对于使用线程池的外部来说，线程池的机制是这样的：

1. 如果正在运行的线程数 < coreSize，马上创建线程执行该task，不排队等待；
2. 如果正在运行的线程数 >= coreSize，把该task放入阻塞队列；
3. 如果队列已满 && 正在运行的线程数 < maximumPoolSize，创建新的线程执行该task；
4. 如果队列已满 && 正在运行的线程数 >= maximumPoolSize，线程池调用handler的reject方法拒绝本次提交。

从worker线程自己的角度来看，当worker的task执行结束之后，循环从阻塞队列中取出任务执行。

### 创建任务

任务分为两种:一种是有返回值的（ **callable** ），一种是没有返回值的（ **runnable** ）. Callable与 Future 两功能是Java在后续版本中为了适应多并法才加入的，Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其他线程执行的任务。

### Callable和Runnable的区别如下：

- Callable定义的方法是call，而Runnable定义的方法是run。
- Callable的call方法可以有返回值，而Runnable的run方法不能有返回值。
- Callable的call方法可抛出异常，而Runnable的run方法不能抛出异常。

#### Future 介绍

Future表示异步计算的结果，它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。Future的cancel方法可以取消任务的执行，它有一布尔参数，参数为 true 表示立即中断任务的执行，参数为 false 表示允许正在运行的任务运行完成。Future的 get 方法等待计算完成，获取计算结果。

 执行任务

通过java.util.concurrent.ExecutorService接口对象来执行任务，该对象有两个方法可以执行任务execute和submit。execute这种方式提交没有返回值，也就不能判断是否执行成功。submit这种方式它会返回一个Future对象，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成。

execute与submit区别：

- 接收的参数不一样
- submit有返回值，而execute没有
- submit方便Exception处理
- execute是Executor接口中唯一定义的方法；submit是ExecutorService（该接口继承Executor）中定义的方法

## 关闭线程池

线程池使用完毕，需要对其进行关闭，有两种方法

> shutdown()

说明：shutdown并不是直接关闭线程池，而是不再接受新的任务…如果线程池内有任务，那么把这些任务执行完毕后，关闭线程池

> shutdownNow()

说明：这个方法表示不再接受新的任务，并把任务队列中的任务直接移出掉，如果有正在执行的，尝试进行停止

**什么时候使用线程池？**

- 单个任务处理时间比较短
- 需要处理的任务数量很大

**使用线程池的好处**

- 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

`ctl`是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。 

### ctl相关方法

这里还有几个对ctl进行计算的方法：

```
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

- **runStateOf**：获取运行状态；
- **workerCountOf**：获取活动线程数；
- **ctlOf**：获取运行状态和活动线程数的值。





- 线程池的几种实现方式
- 线程的生命周期，状态是如何转移的

## **线程的几种状态**

线程一共有以下几种状态：

**1、新建状态(New)**：新创建了一个线程对象。
**2、就绪状态(Runnable)**：线程对象创建后，其他线程调用了该对象的`start()`方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，即**在就绪状态的线程除CPU之外，其它的运行所需资源都已全部获得。**
**3、运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。
**4、阻塞状态(Blocked)**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

- ①. 等待阻塞：运行的线程执行`wait()`方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的必须依靠其他线程调用`notify()`或`notifyAll()`方法才能被唤醒。
- ②. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
- ③. 其他阻塞：运行的线程执行`sleep()`或`join()`方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当`sleep()`状态超时、`join()`等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态。

**5、死亡状态(Dead)**：线程执行完了或者因异常退出了`run()`方法，该线程结束生命周期。

线程变化的状态转换图如下：

![](D:\workspace\Github\node\瑞秋\201\assets/149974_1450349079825_4697A22AC611680A692472687DEC1CFD.png)

拿到对象的锁标记，即为获得了对该对象(临界区)的使用权限。即该线程获得了运行所需的资源，进入“就绪状态”，只需获得CPU，就可以运行。

因为当调用wait()后，线程会释放掉它所占有的“锁标志”，所以线程只有在此获取资源才能进入就绪状态。

下面作下解释：

- 线程的实现有两种方式，一是继承Thread类，二是实现Runnable接口，但不管怎样， 当我们new了这个对象后，线程就进入了初始状态；

- 当该对象调用了start()方法，就进入就绪状态；

- 进入就绪后，当该对象被操作系统选中，获得CPU时间片就会进入运行状态；

- 进入运行状态后情况就比较复杂；

  - `run()`方法或`start()`方法结束后，线程就进入终止状态；
  - 当线程调用了自身的`sleep()`方法或其他线程的`join()`方法，进程让出CPU，然后就会进入阻塞状态（该状态既停止当前线程，但并不释放所占有的资源，即调用`sleep()`函数后，线程不会释放它的“锁标志”。）。当`sleep()`结束或`join()`结束后，该线程进入可运行状态，继续等待OS分配CPU时间片；典型地，`sleep()`被用在等待某个资源就绪的情形；测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。
  - 线程调用了`yield()`方法，意思是放弃当前获得的CPU时间片，回到就绪状态，这时与其他进程处于同等竞争状态，OS有可能会接着又让这个进程进入运行状态；调用`yield()` 的效果等价于调度程序认为该线程已执行了足够的时间片从而需要转到另一个线程。`yield()`只是使当前线程重新回到可执行状态，所以执行`yield()`的线程有可能在进入到可执行状态后马上又被执行。
  - 当线程刚进入可运行状态（注意，还没运行），发现将要调用的资源被synchronized（同步），获取不到锁标记，将会立即进入锁池状态，等待获取锁标记（这时的锁池里也许已经有了其他线程在等待获取锁标记，这时它们处于队列状态，既先到先得），一旦线程获得锁标记后，就转入就绪状态，等待OS分配CPU时间片。
  - `suspend()`和 `resume()`方法：两个方法配套使用，`suspend()`使得线程进入阻塞状态，并且不会自动恢复，必须其对应的`resume()`被调用，才能使得线程重新进入可执行状态。典型地，`suspend()`和 `resume()`被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用`resume()`使其恢复。
  - `wait()`和`notify()`方法：当线程调用`wait()`方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用`notify()`或`notifyAll()`方法才能被唤醒（由于`notify()`只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒， 因此在实际使用时，一般都用`notifyAll()`方法，唤醒有所线程），线程被唤醒后会进入锁池，等待获取锁标记。 **wait() 使得线程进入阻塞状态，它有两种形式：**一种允许指定以ms为单位的时间作为参数，另一种没有参数。前者当对应的`notify()`被调用或超出指定时间时线程重新进入可执行状态即就绪状态，后者则必须对应的`notify()`被调用。 当调用`wait()`后，线程会释放掉它所占有的“锁标志”，从而使线程所在对象中的其它synchronized数据可被别的线程使用。`wait()`和`notify()`因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronized block中进行调用。 如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生**IllegalMonitorStateException**的异常。

  ![](D:\workspace\Github\node\瑞秋\201\assets/java-thread-state.png)

# Phaser

java7中引入了一种新的可重复使用的同步屏障,称为移相器`Phaser`.`Phaser`拥有与`CyclicBarrier`和`CountDownLatch`类似的功劳.但是这个类提供了更加灵活的应用.`CountDownLatch`和`CyclicBarrier`都是只适用于固定数量的参与者.移相器适用于可变数目的屏障,在这个意义上,可以在任何时间注册新的参与者.并且在抵达屏障是可以注销已经注册的参与者.因此,注册到同步移相器的参与者的数目可能会随着时间的推移而变化.如`CyclicBarrier`一样,移相器可以重复使用,这意味着当前参与者到达移相器后,可以再一次注册自己并等待另一次到达.因此,移相器会有多代.一旦为某个特定相位注册的所有参与者都到达移相器,就增加相数.相数从零开始,在达到`Integer.MAX_VALUE`后,再次绕回0.当移相器发生变化时,通过重写`onAdvance`方法,可以自行可选操作.这个方法也可用于终止移相器.移相器一旦被终止,所有的同步方法就会立即返回,并尝试注册新的失败的参与者.  移相器的另一个重要特征是:移相器可能是分层的,这允许你以树形结构来安排移相器以减少竞争.很明显,更小的组将拥有更少的竞争同步的参与者.因此,将大量的参与者分成较小的组可以减少竞争.虽然创建移相器能增加中的吞吐量,但是这需要更多的开销.最后,移相器的另一个重要的特征在于监控功能,使用独立的对象可以监视移相器的当前状态.监视器可以查询注册到移相器的参与者的数量,以及已经到达和还没有到达某个特定相数的参与者的数量.[1](https://blog.csdn.net/tianshi_kco/article/details/52975468#fn:java7) 

​    Phaser类的功能和CyclicBarrier、CountDownLatch的有很多类似的地方，例如线程互相等待，等待某个线程完成再进行其他任务，这在Phaser都可以实现，而Phaser却更加的灵活，因为它可以动态的注册线程数量，取消注册数量，这可以给我们带来更多的控制。

### **3. Phaser** 

Phaser 其实就是CyclicBarrier的改良版，可真正的实现多次重复利用，因为要是在CyclicBarrier的 advance Action里reset的话，就抛异常了不能重复使用，但是在Phaser的onAdvance()里就可以做你向做的事，控制返回值是否为true来结束；

**3.1 Registration**

​    Phaser支持通过register()和bulkRegister(int parties)方法来动态调整注册任务的数量，此外也支持通过其构造函数进行指定初始数量。在适当的时机，Phaser支持减少注册任务的数量，例如arriveAndDeregister()。单个Phaser实例允许的注册任务数的上限是65535。

**3.2 Arrival**

​    正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。arrive()和arriveAndDeregister()方法用于记录到达，arriveAndAwaitAdvance()方法用于记录到达，并且等待其它未到达的任务。

**3.3 Termination**

​    Phaser支持终止。Phaser终止之后，调用register()和bulkRegister(int parties)方法没有任何效果，arriveAndAwaitAdvance()方法也会立即返回。触发终止的时机是在protected boolean onAdvance(int phase, int registeredParties)方法返回时，如果该方法返回true，那么Phaser会被终止。默认实现是在注册任务数为0时返回true（即return registeredParties == 0;）。此外，forceTermination()方法用于强制终止，isTerminated()方法用于判断是否已经终止。

**3.4 Tiering**

​    Phaser支持层次结构，即通过构造函数Phaser(Phaser parent)和Phaser(Phaser parent, int parties)构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。

Phaser是一个更强大的、更复杂的同步辅助类，可以代替CyclicBarrier CountDownLatch的功能，但是比他们更强大。 
        Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才能进行下一步。 
        当我们有并发任务并且需要分解成几步执行的时候，这种机制就非常适合。 
        CyclicBarrier CountDownLatch 只能在构造时指定参与量，而phaser可以动态的增减参与量。
        phaser 使用说明：

- 使用phaser.arriveAndAwaitAdvance(); //等待参与者达到指定数量，才开始运行下面的代码
- 使用phaser.arriveAndDeregister(); //注销当前线程，该线程就不会进入休眠状态，也会从phaser的数量中减少
- 模拟代替CountDownLatch功能，只需要当前线程arriveAndAwaitAdvance()之后运行需要的代码之后，就arriveAndDeregister()取消当前线程的注册。
- phaser有一个重大特性，就是不必对它的方法进行异常处理。置于休眠的线程不会响应中断事件，不会抛出interruptedException异常， 只有一个方法会响应：AwaitAdvanceInterruptibly(int phaser).

​       其他api

- arrive()：这个方法通知phase对象一个参与者已经完成了当前阶段，但是它不应该等待其他参与者都完成当前阶段，必须小心使用这个方法，因为它不会与其他线程同步。
- awaitAdvance(int phase)：如果传入的阶段参数与当前阶段一致，这个方法会将当前线程至于休眠，直到这个阶段的所有参与者都运行完成。如果传入的阶段参数与当前阶段不一致，这个方法立即返回。
- awaitAdvanceInterruptibly(int phaser):这个方法跟awaitAdvance(int phase)一样，不同处是：该访问将会响应线程中断。会抛出interruptedException异常

​        将参与者注册到phaser中：

- register():将一个新的参与者注册到phase中，这个新的参与者将被当成没有执完本阶段的线程。
- bulkRegister(int parties)：将指定数目的参与者注册到phaser中，所有这些新的参与者都将被当成没有执行完本阶段的线程。

​        减少参与者 

- 只提供了一个方法来减少参与者：arriveAndDeregister():告知phaser对应的线程已经完成了当前阶段，并它不会参与到下一阶段的操作中。

​       强制终止 

- 当一个phaser么有参与者的时候，它就处于终止状态，使用forceTermination()方法来强制phaser进入终止状态，不管是否存在未注册的参与线程，当一个线程出现错误时，强制终止phaser是很有意义的。

​       当phaser处于终止状态的时候，arriveAndAwaitAdvance() 和 awaitAdvance() 立即返回一个负数，而不再是一个正值了，如果知道phaser可能会被终止，就需要验证这些方法的值，以确定phaser是不是被终止了。 

被终止的phaser不会保证参与者的同步。



一个Phaser对象有两个状态：

- 活跃态：当存在参与同步的线程的时候，Phaser就是活跃的，并且在每个阶段结束的时候进行同步。
- 终止态：当所有的线程都取消注册的时候，Phaser就处于终止态，此时Phaser没有任何参与者。

Phaser类一个重大的特性就是不必对他的方法进行异常处理。



​    Phaser有几个重要的方法：

​        1.arrive:该方法简单的说就是记录到达的线程数，有点像CountDownLatch的countDown，该方法调用后不会等待其他线程

​        2.arriveAwaitAdvance:该方法和arrive一样，但是该方法调用会等待其他未到达的线程

​        3.arriveAndDeregister:该方法和arrive一样，但是该方法调用后会减少注册的数量

​        4.register:该方法可以动态的注册一个线程数量

Phaser替代CyclicBarrier比较简单，CyclicBarrier的await()方法可以直接用Phaser的arriveAndAwaitAdvance()方法替代  `CyclicBarrier`与`Phaser`:`CyclicBarrier`只适用于固定数量的参与者,而`Phaser`适用于可变数目的屏障. 

CountDownLatch主要使用的有2个方法  * await()方法，可以使线程进入等待状态，在Phaser中，与之对应的方法是awaitAdvance(int n)。   countDown()，使计数器减一，当计数器为0时所有等待的线程开始执行，在Phaser中，与之对应的方法是arrive()

​    实际上，即使 当前线程被中断，arriveAndAwaitAdvance()方法也不会返回，而是继续等待。如果在等待时希望可中断，或者可超时，那么需要使用以下 方法：

Java代码  ![收藏代码](http://whitesock.iteye.com/images/icon_star.png)

```java
awaitAdvance(arrive())  // 等效于arriveAndAwaitAdvance()  
awaitAdvanceInterruptibly(int phase)  
awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)  
```



​    有如下情景：学生进行考试，需要全部考生都考完之后才可以离场，代码如下：

```
public class PhaserTest1 {
	public static void main(String[] args) {
		Phaser phaser = new Phaser(5);
		for (int i = 0; i < 5; i++) {
			new Thread(new Student(phaser, "考生" + i)).start();
		}
	}
 
	public static class Student implements Runnable {
		private Phaser phaser;
		private String name;
 
		public Student(Phaser phaser, String name) {
			this.phaser = phaser;
			this.name = name;
		}
 
		@Override
		public void run() {
			try {
				System.out.println(name + "进入考场，开始考试....");
				Thread.sleep((int) (Math.random() * 10) * 1000);
				System.out.println(name + "考完,等待其他考生考完后离场");
				phaser.arriveAndAwaitAdvance();// 使用该方法会阻塞,直到所有线程都到达这个点程序才继续运行
				System.out.println(name + "考生离场....");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
 
}

```

​    结果如下

```
//考生1进入考场，开始考试....
//考生3进入考场，开始考试....
//考生0进入考场，开始考试....
//考生2进入考场，开始考试....
//考生4进入考场，开始考试....
//考生1考完,等待其他考生考完后离场
//考生0考完,等待其他考生考完后离场
//考生4考完,等待其他考生考完后离场
//考生3考完,等待其他考生考完后离场
//考生2考完,等待其他考生考完后离场
//考生4考生离场....
//考生0考生离场....
//考生2考生离场....
//考生3考生离场....
//考生1考生离场....

```

​    Phaser初始化的时候，传入了参数5，则表示当调用了arriveAndAwaitAdvance方法之后，该线程会阻塞直到5个线程都到达这里才会继续执行后面的代码

​    如果初始化的时候，传入的是6，那么这5个线程就会一直等待

​    如果将arriveAndAwaitAdvance改成arrive，那么结果是：

```
//考生0进入考场，开始考试....
//考生1进入考场，开始考试....
//考生3进入考场，开始考试....
//考生4进入考场，开始考试....
//考生2进入考场，开始考试....
//考生0考完,等待其他考生考完后离场
//考生0考生离场....
//考生1考完,等待其他考生考完后离场
//考生1考生离场....
//考生3考完,等待其他考生考完后离场
//考生3考生离场....
//考生4考完,等待其他考生考完后离场
//考生4考生离场....
//考生2考完,等待其他考生考完后离场
//考生2考生离场....

```

​    接下来看下arriveAndDeregister方法，修改main方法中的代码，如下

```
	public static void main(String[] args) {
		Phaser phaser = new Phaser(6);// 初始化注册线程数量为6
		for (int i = 0; i < 5; i++) {// 只有5个线程，如果没有其他操作，那么线程会一直阻塞
			new Thread(new Student(phaser, "考生" + i)).start();
		}
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();
		phaser.arriveAndDeregister();//调用该方法，减少注册是数量，即6->5，那么原有的5个线程已经满足条件，所有线程继续执行
		System.out.println("考试结束");
	}

```

 

```
考生0进入考场，开始考试....
考生2进入考场，开始考试....
考生4进入考场，开始考试....
考生1进入考场，开始考试....
考生3进入考场，开始考试....
考生0考完,等待其他考生考完后离场
考生4考完,等待其他考生考完后离场
考生2考完,等待其他考生考完后离场
考生3考完,等待其他考生考完后离场
考生1考完,等待其他考生考完后离场
 
考试结束
考生2考生离场....
考生4考生离场....
考生0考生离场....
考生1考生离场....
考生3考生离场....

```

​    接下来再说下register方法

​    

```
public class PhaserTest2 {
	public static void main(String[] args) {
		Phaser phaser = new Phaser(1);// 注册了一个线程
		for (int i = 0; i < 5; i++) {
			new Thread(new Student(phaser, "考生" + i)).start();
		}
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();
		phaser.arriveAndDeregister();
		System.out.println("考试结束");
 
	}
 
	public static class Student implements Runnable {
		private Phaser phaser;
		private String name;
 
		public Student(Phaser phaser, String name) {
			this.phaser = phaser;
			this.name = name;
		}
 
		@Override
		public void run() {
			try {
				phaser.register();// 每个子线程都会注册一次，所有最后一共有6个注册线程
				System.out.println(name + "进入考场，开始考试....");
				Thread.sleep((int) (Math.random() * 10) * 1000);
				System.out.println(name + "考完,等待其他考生考完后离场");
				phaser.arriveAndAwaitAdvance();// 使用该方法会阻塞,直到所有线程都到达这个点程序才继续运行
				System.out.println(name + "考生离场....");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}

```

​    Phaser还有一个用法，就是重写onAdvance方法。当所有线程都到达了(即使用了arrive、arriveAndAwaitAdvance、arriveAndDeregister方法)，那么就会调用onAdvance方法一次。

​    该方法有两个参数，一个参数是代表当前是第几个阶段(所有线程到达一次为一个阶段，从0开始)

​    如果考生需要考语数英3门考试，这3门考试是阶段性的，一门接着一门，那么可以通过重写onAdvance方法，来对每个阶段进行处理，这里只是打印出一条信息

```
public class PhaserTest3 {
	public static void main(String[] args) {
		Phaser phaser = new Phaser(5) {
			@Override
			protected boolean onAdvance(int phase, int registeredParties) {
				switch (phase) {
				case 0:
					System.out.println("所有考生考完数学....");
					return false;
				case 1:
					System.out.println("所有考生考完语文....");
					return false;
				case 2:
					System.out.println("所有考生考完英语....");
					return false;
				default:
					System.out.println("phase:" + phase);
					return true;
				}
			}
		};
		for (int i = 0; i < 5; i++) {
			new Thread(new Student(phaser, "考生" + i)).start();
		}
	}
 
	public static class Student implements Runnable {
		private Phaser phaser;
		private String name;
 
		public Student(Phaser phaser, String name) {
			this.phaser = phaser;
			this.name = name;
		}
 
		@Override
		public void run() {
			try {
				System.out.println(name + "：数学考试开始");
				Thread.sleep((int) (Math.random() * 10) * 1000);
				System.out.println(name + "考完数学,等待其他考生考完后参加下一场考试");
				phaser.arriveAndAwaitAdvance();//
 
				System.out.println(name + "：语文考试开始");
				Thread.sleep((int) (Math.random() * 10) * 1000);
				System.out.println(name + "考完语文,等待其他考生考完后参加下一场考试");
				phaser.arriveAndAwaitAdvance();//
 
				System.out.println(name + "：英语考试开始");
				Thread.sleep((int) (Math.random() * 10) * 1000);
				System.out.println(name + "考完英语,等待其他考生考完后参加下一场考试");
				phaser.arriveAndAwaitAdvance();//
 
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
//考生0：数学考试开始
//考生2：数学考试开始
//考生4：数学考试开始
//考生1：数学考试开始
//考生3：数学考试开始
//考生0考完数学,等待其他考生考完后参加下一场考试
//考生4考完数学,等待其他考生考完后参加下一场考试
//考生3考完数学,等待其他考生考完后参加下一场考试
//考生2考完数学,等待其他考生考完后参加下一场考试
//考生1考完数学,等待其他考生考完后参加下一场考试
//所有考生考完数学....
//考生2：语文考试开始
//考生4：语文考试开始
//考生0：语文考试开始
//考生1：语文考试开始
//考生1考完语文,等待其他考生考完后参加下一场考试
//考生3：语文考试开始
//考生3考完语文,等待其他考生考完后参加下一场考试
//考生2考完语文,等待其他考生考完后参加下一场考试
//考生0考完语文,等待其他考生考完后参加下一场考试
//考生4考完语文,等待其他考生考完后参加下一场考试
//所有考生考完语文....
//考生0：英语考试开始
//考生2：英语考试开始
//考生4：英语考试开始
//考生3：英语考试开始
//考生1：英语考试开始
//考生1考完英语,等待其他考生考完后参加下一场考试
//考生2考完英语,等待其他考生考完后参加下一场考试
//考生4考完英语,等待其他考生考完后参加下一场考试
//考生3考完英语,等待其他考生考完后参加下一场考试
//考生0考完英语,等待其他考生考完后参加下一场考试
//所有考生考完英语....

```

# 高级用法

前面两个例子都比较简单,现在我们还用`Phaser`一个比较高级一点用法.还是用旅游的例子 
假如有这么一个场景,在旅游过程中,有可能很凑巧遇到几个朋友,然后他们听说你们在旅游,所以想要加入一起继续接下来的旅游.也有可能,在旅游过程中,突然其中有某几个人临时有事,想退出这次旅游了.在自由行的旅游,这是很常见的一些事情.如果现在我们使用`CyclicBarrier`这个类来实现,我们发现是实现不了,这是用`Phaser`就可实现这个功能.

- 首先,我们改写旅游类 `TourismRunnable`,这次改动相对比较多一点

```
public class TourismRunnable implements Runnable{
    Phaser phaser;
    Random random;
    /**
     * 每个线程保存一个朋友计数器,比如小红第一次遇到一个朋友,则取名`小红的朋友0号`,
     * 然后旅游到其他景点的时候,如果小红又遇到一个朋友,这取名为`小红的朋友1号`
     */
    AtomicInteger frientCount = new AtomicInteger();
    public TourismRunnable(Phaser phaser) {
        this.phaser = phaser;
        this.random = new Random();
    }

    @Override
    public void run() {
        tourism();
    }

    /**
     * 旅游过程
     */
    private void tourism() {
        switch (phaser.getPhase()){
            case 0:if(!goToStartingPoint()) break;
            case 1:if(!goToHotel()) break;
            case 2:if(!goToTourismPoint1()) break;
            case 3:if(!goToTourismPoint2()) break;
            case 4:if(!goToTourismPoint3()) break;
            case 5:if(!goToEndPoint()) break;
        }
    }

    /**
     * 准备返程
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToEndPoint() {
        return goToPoint("飞机场,准备登机回家");
    }

    /**
     * 到达旅游点3
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToTourismPoint3() {
        return goToPoint("旅游点3");
    }

    /**
     * 到达旅游点2
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToTourismPoint2() {
        return goToPoint("旅游点2");
    }

    /**
     * 到达旅游点1
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToTourismPoint1() {
        return goToPoint("旅游点1");
    }

    /**
     * 入住酒店
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToHotel() {
        return goToPoint("酒店");
    }

    /**
     * 出发点集合
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToStartingPoint() {
        return goToPoint("出发点");
    }

    private int getRandomTime() throws InterruptedException {
        int time = random.nextInt(400) + 100;
        Thread.sleep(time);
        return time;
    }

    /**
     * @param point 集合点
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean goToPoint(String point){
        try {
            if(!randomEvent()){
                phaser.arriveAndDeregister();
                return false;
            }
            String name = Thread.currentThread().getName();
            System.out.println(name + " 花了 " + getRandomTime() + " 时间才到了" + point);
            phaser.arriveAndAwaitAdvance();
            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    /**
     * 随机事件
     * @return 返回true,说明还要继续旅游,否则就临时退出了
     */
    private boolean randomEvent() {
        int r = random.nextInt(100);
        String name = Thread.currentThread().getName();
        if (r < 10){
            int friendNum =  1;
            System.out.println(name + ":在这里竟然遇到了"+friendNum+"个朋友,他们说要一起去旅游...");
            phaser.bulkRegister(friendNum);
            for (int i = 0; i < friendNum; i ++){
                new Thread(new TourismRunnable(phaser), name + "的朋友" + frientCount.getAndAdd(1) + "号").start();
            }
        }else if(r > 90){
            System.out.println(name + ":突然有事要离开一下,不和他们继续旅游了....");
            return false;
        }
        return true;
    }
}
```

> 代码解析
>
> > `tourism`这个方法的case写法看起有点怪异,如果是为了满足我们这个需求,这里的case的意思是–>`case 第几次集合: if(是否继续旅游) 若不继续则break,否则继续后面的旅游` 
> > `phaser.getPhase()` 初始值为0,如果全部人到达集合点这个`Phase`+1,如果`phaser.getPhase()`达到Integer的最大值,这重新清空为0,在这里表示第几次集合了 
> > `phaser.arriveAndDeregister();` 表示这个人旅游到这个景点之后,就离开这个旅游团了 
> > `phaser.arriveAndAwaitAdvance();` 表示这个人在这个景点旅游完,在等待其他人 
> > `phaser.bulkRegister(friendNum);` 表示这个人在这个景点遇到了`friendNum`个朋友,他们要加入一起旅游

- 最后我们的测试代码还是差不多的,比例子1多了一个到齐后的操作

```
public class TestMain {

    public static void main(String[] args) {
        String name = "明刚红丽黑白";
        Phaser phaser = new SubPhaser(name.length());
        List<Thread> tourismThread = new ArrayList<>();
        for (char ch : name.toCharArray()){
            tourismThread.add(new Thread(new TourismRunnable(phaser), "小" + ch));
        }
        for (Thread thread : tourismThread){
            thread.start();
        }
    }
    public static class SubPhaser extends Phaser{
        public SubPhaser(int parties) {
            super(parties);
        }

        @Override
        protected boolean onAdvance(int phase, int registeredParties) {

            System.out.println(Thread.currentThread().getName() + ":全部"+getArrivedParties()+"个人都到齐了,现在是第"+(phase + 1)
                    +"次集合准备去下一个地方..................\n");
            return super.onAdvance(phase, registeredParties);
        }
    }
}
```

运行输出以下结果:

```
小白 花了 109 时间才到了出发点
小红 花了 135 时间才到了出发点
小丽 花了 218 时间才到了出发点
小黑 花了 297 时间才到了出发点
小明 花了 303 时间才到了出发点
小刚 花了 440 时间才到了出发点
小刚:全部6个人都到齐了,现在是第1次集合准备去下一个地方..................

小明:突然有事要离开一下,不和他们继续旅游了....
小刚:突然有事要离开一下,不和他们继续旅游了....
小红 花了 127 时间才到了酒店
小丽 花了 162 时间才到了酒店
小黑 花了 365 时间才到了酒店
小白 花了 474 时间才到了酒店
小白:全部4个人都到齐了,现在是第2次集合准备去下一个地方..................

小黑:突然有事要离开一下,不和他们继续旅游了....
小丽:突然有事要离开一下,不和他们继续旅游了....
小红 花了 348 时间才到了旅游点1
小白 花了 481 时间才到了旅游点1
小白:全部2个人都到齐了,现在是第3次集合准备去下一个地方..................

小白 花了 128 时间才到了旅游点2
小红 花了 486 时间才到了旅游点2
小红:全部2个人都到齐了,现在是第4次集合准备去下一个地方..................

小红 花了 159 时间才到了旅游点3
小白 花了 391 时间才到了旅游点3
小白:全部2个人都到齐了,现在是第5次集合准备去下一个地方..................

小白:在这里竟然遇到了1个朋友,他们说要一起去旅游...
小白 花了 169 时间才到了飞机场,准备登机回家
小红 花了 260 时间才到了飞机场,准备登机回家
小白的朋友0号 花了 478 时间才到了飞机场,准备登机回家
小白的朋友0号:全部3个人都到齐了,现在是第6次集合准备去下一个地方..................
```

### **1.4、锁机制**

#### 说说线程安全问题，什么是线程安全，如何保证线程安全

##### 产生线程不安全的原因

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。

**死锁**和**脏数据**就是典型的**线程安全**问题。

简单来说，线程安全就是： **在多线程环境中，能永远保证程序的正确性。**

只有存在**共享数据**时才需要考虑线程安全问题。

**方法区**和**堆**就是主要的线程共享区域。那么就是说共享对象只可能是类的属性域或静态域。 







- 重入锁的概念，重入锁为什么可以防止死锁
- 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）
- 如何检查死锁（通过jConsole检查死锁）
- volatile 实现原理（禁止指令重排、刷新内存）
- synchronized 实现原理（对象监视器）
- synchronized 与 lock 的区别
- AQS同步队列
- CAS无锁的概念、乐观锁和悲观锁
- 常见的原子操作类

java.util.concurrent.atomic包一共提供了13个类，属于4中类型的原子更新方式：原子更新基本数据类型、原子更新数组、原子更新引用、原子更新属性。 

### 原子更新基本类型类

使用原子的方式更新基本类型。包括下面3个类：
 AtomicBoolean：boolean类型
 AtomicInteger：原子更新整形
 AtomicLong：原子更新长整形

AtomicInteger常用方法：

-  `int addAndGet(int delta)`：相加并返回结果
-  `boolean compareAndSet(int expect, int update)`：如果当前值等于预期值，那么将该值设置为输入的值。
-  `int getAndIncrement()`：返回当前值，然后将当前值加一
-  `void lazySet(int newValue)`：最终会设置成newValue，但是在设置值之后，其他线程在一段时间内还可以读到旧的值。
-  `int getAndSet(int newValue)`：返回当前值，然后将当前值设置成新值。

### 原子更新数组

通过原子的方式更新数组中的某个元素，Atomic包提供了一下3个类：

-  `AtomicIntegerArray`：原子更新整形数组里的元素
-  `AtomicLongArray`：原子更新长整形数组里的元素
-  `AtomicReferenceArray`：原子更新引用类型数组里的元素

**注意**：数组通过构造方法传给AtomicIntegerArray会将当前的数组复制一份，以后在复制的对象上进行操作。不会更改原来数组的值。

`AtomicIntegerArray`主要提供原子的方式更新数组里的整形：

-  `int addAndGet(int i, int delta)`：原子方式将输入值与数组里索引i的元素相加。
-  `boolean compareAndSet(int i, int expect, int update)`：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值

###  原子更新引用类型

Atomic包提供了3个类：

-  `AtomicReference`：原子更新引用类型
-  `AtomicReferenceFieldUpdater`：原子更新引用类型里的字段
-  `AtomicMarkableReference`：原子更新带有标志位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是`AtomicMarkableReference(V initialRef, boolean initialMark)`

### 原子更新字段类

需要原子更新某个类里的某个字段时，需要使用原子更新字段类。Atomic包提供了3个类：

-  `AtomicIntegerFieldUpdate`：原子更新整形的字段的更新器
-  `AtomicLongFieldUpdate`：原子更新长整形的字段的更新器
-  `AtomicStampedReference`：原子更新带有版本号的引用类型

想要原子的更新字段类需要两步：

1. 因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法`newUpdater()`创建一个更新器，并且需要设置想要更新的类和属性。
2. 更新类的字段必须使用public volatile修饰符。

**注意：**
 被更新的字段必须是`public volatile`。

 

============================================================================================================================================================================================================================

### 什么是ABA问题，出现ABA问题JDK是如何解决的

**优化方向**：CAS不能只比对“值”，还必须确保的是原来的数据，才能修改成功。  **常见实践**：“版本号”的比对，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。 

用AtomicStampedReference/AtomicMarkableReference解决ABA问题

#### AtomicStampedReference

除了对象值，AtomicStampedReference内部还维护了一个“`状态戳`”。状态戳可类比为时间戳，是一个整数值，*每一次修改对象值的同时，也要修改状态戳，从而区分相同对象值的不同状态*。当AtomicStampedReference设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功。

AtomicStampedReference的几个API在AtomicReference的基础上新增了有关时间戳的信息：

```
//比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳
public boolean compareAndSet(V expectedReference, V newReference, 
    int expectedStamp, int newStamp)
//获得当前对象引用
public V getReference()
//获得当前时间戳
public int getStamp()
//设置当前对象引用和时间戳
public void set(V newReference, int newStamp)
```

####  AtomicMarkableReference

AtomicMarkableReference和AtomicStampedReference功能相似，但**AtomicMarkableReference描述更加简单的是与否的关系**。它的定义就是将状态戳简化为`true|false`。如下：

```
public final static AtomicMarkableReference<String> ATOMIC_MARKABLE_REFERENCE 
    = new AtomicMarkableReference<>("abc" , false);
```

操作时：

```
ATOMIC_MARKABLE_REFERENCE.compareAndSet("abc", "abc2", false, true);
```



ABA问题在有些业务上可能没有影响，可以根据需求进行是否需要解决；通常解决的方案是
 （1）使用double-cas；（最通常的情况）
 （2）使用safe_read，即对资源进行引用计数；（针对resource是指针的情况下，由于resource是指针进行了引用计数管理后，可以确保指针指向的区域不会被释放后又复用，即避免了ABA问题）
 对应的逻辑代码如下

```
//double-cas
do{
expected_A_C = resource_A_C;//这个示意不太准确，具体可以Google
some operation;          
｝while(CAS(resource, expected_A_C , new_value) == true);
//safe_read
do{
expected = safe_read(resource)；//获取一次预期值，引用计数+1
some operation;          
｝while(CAS(resource, expected, new_value) == true);
release(); //引用计数-1
```

使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容

1）一次用CAS检查双倍长度的值，前半部是指针，后半部分是一个计数器。

2）只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。

这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）





### 乐观锁的业务场景及实现方式

在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁解决并发问题；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法. 

```
[QA]什么是悲观锁和乐观锁？1
```

| 术语   | 描述                                                         | 常见案例                                       |
| ------ | ------------------------------------------------------------ | ---------------------------------------------- |
| 乐观锁 | 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据 | 版本号控制，适用于多读少写的场景               |
| 悲观锁 | 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁 | DB的行锁、表锁等，适用于数据一致性比较高的场景 |

一般实现乐观锁的方式：

 [1] 版本号控制：一般会在数据库表增加一个version字段，这个字段标识当前数据的版本，每次更新操作都会version+=1 

 [2] 时间戳控制 ：时间戳的方式与版本号实际上原理差不多，每次更新数据时，会更新该时间戳字段，以标识数据的更新情况 

悲观锁的实现一般都是通过锁机制来实现的，锁可以简单理解为资源的访问的入口。如果要对一个具有锁属性的资源执行访问时，在更新操作时，需要持锁权才能进行操作，但是往往这种操作可以保证数据的一致性和完整性。 

### 什么时候使用悲观锁？

```
    一旦通过悲观锁锁定一个资源，那么其他需要操作该资源的使用方，只能等待直到锁被释放，好处在于可以减少并发，但是当并发量非常大的时候，由于锁消耗资源，并且可能锁定时间过长，容易导致系统性能下降，资源消耗严重。因此一般我们可以在并发量不是很大，并且出现并发情况导致的异常用户和系统都很难以接受的情况下，会选择悲观锁进行。1
```

### [5.2] 什么时候使用乐观锁?

```
    乐观锁实际上并没用实际的锁资源操作，就如上面概述的版本号和时间戳方式一样，使用方都可以操作相应的资源，而当第一个使用方提交之后，其他使用方提交时，会出现异常（例如：代码版本控制器SVN,GIT），其可以增加系统的并发处理能力，但是如果并发导致了资源提交冲突，其他使用方需要重新读取资源，会增加读的次数，但是可以面对高并发场景，前提是如果出现提交失败，用户是可以接受的。因此一般乐观锁只用在高并发、多读少写的场景。
    其中：GIT,SVN,CVS等代码版本控制管理器，就是一个乐观锁使用很好的场景，例如：A、B程序员，同时从SVN服务器上下载了code.html文件，当A完成提交后，此时B再提交，那么会报版本冲突，此时需要B进行版本处理合并后，再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁，那么意味者所有程序员都必须一个一个等待操作提交完，才能访问文件，这是难以接受的。12
```



- Java 8并法包下常见的并发类
- 偏向锁、轻量级锁、重量级锁、自旋锁的概念

### **1.5、JVM**

- JVM运行时内存区域划分
- 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决



概念

- 内存泄露:代码中的某个对象本应该被虚拟机回收，但因为拥有GCRoot引用而没有被回收。关于GCRoot概念，下一篇文章讲解。
- 内存溢出: 虚拟机由于堆中拥有太多不可回收对象没有回收，导致无法继续创建新对象。

1、 内存溢出的原因是什么？

​       内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。如果出现这种现象可行代码排查：

一）是否App中的类中和引用变量过多使用了Static修饰 如public staitc Student s；在类中的属性中使用 static修饰的最好只用基本类型或字符串。如public static int i = 0; //public static String str;

二）是否App中使用了大量的递归或无限递归（递归中用到了大量的建新的对象）

三）是否App中使用了大量循环或死循环（循环中用到了大量的新建的对象）

四）检查App中是否使用了向数据库查询所有记录的方法。即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。

五）检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放。会大量存储在内存中。

六）检查是否使用了“非字面量字符串进行+”的操作。因为String类的内容是不可变的，每次运行"+"就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。

如String s1 = "My name";

String s2 = "is";

String s3 = "xuwei";

String str = s1 + s2 + s3 +.........;这是会容易造成内存溢出的

但是String str =  "My name" + " is " + " xuwei" + " nice " + " to " + " meet you"; //但是这种就不会造成内存溢出。因为这是”字面量字符串“，在运行"+"时就会在编译期间运行好。不会按照JVM来执行的。

在使用String,StringBuffer,StringBuilder时，如果是字面量字符串进行"+"时，应选用String性能更好；如果是String类进行"+"时，在不考虑线程安全时，应选用StringBuilder性能更好。

```java
public class Test {  
  
    public void testHeap(){  
        for(;;){  //死循环一直创建对象，堆溢出
              ArrayList list = new ArrayList (2000);  
          }  
    }  
    int num=1;  
    public void testStack(){  //无出口的递归调用，栈溢出
         num++;  
         this.testStack();  
      }  
       
     public static void main(String[] args){  
         Test  t  = new Test ();  
         t.testHeap();  
         t.testStack();     
     }  
 }
```

 	

七）使用 DDMS工具进行查找内存溢出的大概位置

**2、栈溢出的原因**

​      一）、是否有递归调用

二）、是否有大量循环或死循环

三）、全局变量是否过多

四）、 数组、List、map数据是否过大

五）使用DDMS工具进行查找大概出现栈溢出的位置

- JDK7之前(包括JDK7)拥有"永久代"(PermGen space),用来实现方法区。但在JDK7中已经逐渐在实现中把永久代中把很多东西移了出来，比如:符号引用(Symbols)转移到了native heap,运行时常量池(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap.
  所以这就是为什么我说上一篇文章中说方法区中包含运行时常量池是不正确的，因为已经移动到了java heap;
- 在JDK7之前(包括7)可以通过-XX:PermSize -XX:MaxPermSize来控制永久代的大小.
- JDK8正式去除"永久代",换成Metaspace(元空间)作为JVM虚拟机规范中方法区的实现。
- 元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但仍可以通过参数控制:-XX:MetaspaceSize与-XX:MaxMetaspaceSize来控制大小。

在JDK8的环境下将报出异常:
**Exception in thread "main" java.lang.OutOfMemoryError: Metaspace**
这是因为在调用CGLib的创建代理时会生成动态代理类，即Class对象到Metaspace,所以While一下就出异常了。
**提醒一下:虽然我们日常叫"堆Dump",但是dump技术不仅仅是对于"堆"区域才有效，而是针对OOM的，也就是说不管什么区域，凡是能够报出OOM错误的，都可以使用dump技术生成dump文件来分析。**

在经常动态生成大量Class的应用中，需要特别注意类的回收状况，这类场景除了例子中的CGLib技术，常见的还有，大量JSP，反射，OSGI等。需要特别注意，当出现此类异常，应该知道是哪里出了问题，然后看是调整参数，还是在代码层面优化。



# 内存泄漏与内存溢出的区别:

## **内存泄漏 memory leak**

- **指程序申请了内存后(new),用完的内存没有释放(delete),一直被某个或某些实例所持有却不再被使用导致 GC 不能回收**
- 生活例子 : 电热水器洗完澡不关水,其他人用就没热水的情况
- 内存泄漏是导致内存溢出的原因之一;内存泄漏累积起来就会造成内存溢出
- 内存泄漏可以通过完善代码来避免

## **内存溢出 out of memory**

- **指程序申请内存时,没有足够的内存空间使用**
- 生活例子 : 水杯满了还往里面加水
- 内存溢出可以通过调整配置来减少发生频率,无法彻底避免

- 如何判断对象是否可以回收或存活
- 常见的GC回收算法及其含义
- 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等
- JVM如何设置参数
- JVM性能调优
- 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的
- 类加载的过程：加载、验证、准备、解析、初始化
- 强引用、软引用、弱引用、虚引用

# 内存泄漏的原因:

**以发生的方式来分类,内存泄漏可以分为4类:**

1. **常发性内存泄漏** : 发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
2. **偶发性内存泄漏** : 发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
3. **一次性内存泄漏** : 发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
4. **隐式内存泄漏** : 程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。(重视)

### 小结:

> **一次性内存泄漏没有什么危害,因为它不会堆积,而隐式内存泄漏危害性则非常大,因为较于常发性和偶发性内存泄漏它更难被检测到**

**相关问题**

Q:Java中会存在内存泄漏吗？ 
A: Java中也存在内存泄露。当被分配的对象可达但已无用（未对作废数据内存单元的引用置null）即会引起。

Q: 如何避免内存泄露、溢出？ 
A: 1)尽早释放无用对象的引用。

好的办法是使用临时变量的时候，让引用变量在退出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄露。

2)程序进行字符串处理时，尽量避免使用String，而应使用StringBuffer。

3) 尽量少用静态变量。

因为静态变量是全局的，GC不会回收。

4)避免集中创建对象尤其是大对象，如果可以的话尽量使用流操作。

5)尽量运用对象池技术以提高系统性能。

生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有[大数据](https://link.juejin.im/?target=http%3A%2F%2Flib.csdn.net%2Fbase%2Fhadoop)量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。

6)不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。

可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取那些对象，而不用每次new之后又丢弃。

7) 优化配置



Java内存泄露引起原因 
首先，什么是内存泄露？经常听人谈起内存泄露，但要问什么是内存泄露，没几个说得清楚。内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示 你Out of memory。

内存溢出：指程序运行过程中**无法申请到足够的内存**而导致的一种错误。内**存泄露是内存溢出的一种诱因**，不是唯一因素
那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。具体主要有如下几大类： 
1、静态集合类引起内存泄露： 
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 
例:

```java
Static Vector v = new Vector(10);
for (int i = 1; i<100; i++)
{
  Object o = new Object();
  v.add(o);
  o = null;
}
```

在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。

2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。(修改hashset中对象的参数值，且参数是计算哈希值的字段 )

当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些**参与计算哈希值的字段**，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露。 

应该描述为 HashSet 才准确，因为其他集合并不存在这种问题。要了解在 HashSet 中为什么不起作用，我们需要先看看 HashSet 的实现方式。HashSet 的存储实现其实是依赖于 HashMap，在调用 HashSet 的 add(Object o)方法时，实际上是将对象 o 作为 key，虚拟了一个对象作为 value，将这个 Entry 存入 HashSet 所持有的一个 HashMap 中。源码如下：

```
// ...
// HashSet 维护的 HashMap
private transient HashMap<E,Object> map;
// 与 HashMap Entry相关连的虚拟的值
private static final Object PRESENT = new Object();
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
// ...
```

所以就可以理解为什么网上都是以下面代码作为这种内存泄漏的例子了。

```
HashSet<Student> hashSet = new HashSet<>();
Student xiaoming = new Student("xiaoming", 15);
Student xiaogang = new Student("xiaogang", 14);
hashSet.add(xiaoming);
hashSet.add(xiaogang);
xiaoming.setAge(16); // 此时 xiaoming 对象的 hashCode 值发生改变
hashSet.remove(xiaoming);
hashSet.add(xiaoming);
```

对照代码看：

- 第 6 行：由于更改了对象的属性之后，其 hashCode 会变化
- 第 7 行：从 HashSet 中移除元素时其实就是从 HashSet 持有的那个 HashMap 中移除，在从 HashMap 中根据 key 移除条目时，会计算 key 的 hashCode，而这个 key 其实就是 HashSet 中的元素对象 xiaoming，它的 hashCode 已经改变了
- 第 8 行：所以会移除失败，并且可以再次添加 xiaoming 对象，因为它的 hashCode 变了

然后 HashMap 根据计算得到的 hash 值，再从存储结构中寻找指定的条目并移除，具体实现就不在本文研究范围之内了。

3、监听器 
在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。

4、各种连接 
比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方 法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。

5、内部类和外部模块等的引用 
内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： 
public void registerMsg(Object b); 
这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。

6、单例模式 
不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子： 
显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况



其实，归结于一句话，避免内存泄漏，主要还是：

避免长生命周期对象持有短生命周期对象的引用。



# 线程栈

栈（JVM Stack）存放主要是栈帧( 局部变量表, 操作数栈 , 动态链接 , 方法出口信息 )的地方。注意区分栈和栈帧：栈里包含栈帧。
与线程栈相关的内存异常有两个：
a）、StackOverflowError(方法调用层次太深，内存不够新建栈帧)

b）、OutOfMemoryError（线程太多，内存不够新建线程）

## 1、java.lang.StackOverflowError

栈溢出抛出java.lang.StackOverflowError错误，出现此种情况是因为方法运行的时候，请求新建栈帧时，

栈所剩空间小于战帧所需空间。

例如，通过递归调用方法,不停的产生栈帧,一直把栈空间堆满,直到抛出异常 ：



# 内存泄漏经典模型

#### 静态变量

静态变量的生命周期是最长的，和应用程序的生命周期一样，当一个大对象被一个类的静态变量引用时，这个对象就无法被系统回收，在应用的整个生命周期中占用内存。常见于工具类，一般中存在大量的工具类，很多同学图方便直接或间接使用静态变量引用一个上下文对象的。

规避：

对于工具类，如非频繁使用的对象，尽量不要使用 static 变量去引用，可以在方法执行时候再创建，作为局部变量使用；如需要频繁使用，为了提高方法执行效率，对于上面这种情况可以把Context 参数限制为Application 级别的上下文,避免调用方传递Activity级别的上下文，造成Activity泄漏。

 单例模式

单例模式其实也是静态变量的一种，单例的生命周期和静态变量时一样的，如果这个单例中持有一个大对象，就会引起这个大对象泄漏。

规避：

和静态变量一样的道理，尽量使用Application级别的上下文代替Activity级别的上下文。

#### 内部类

由于内部类的存在需要依赖它的外部类，由于某些原因导致内部类被引用会无法退出，引起外部类无法回收，这是使用最多也是最容易被用出内存泄漏的了。

规避：

对于那些可能长时间执行、阻塞或者被外部引用的内部尽量使用静态内部类代替。静态内部类对象的存在不依附外部类，这样可以避开内部类对外部类的隐性引用，然后使用弱引用持有外部类对象。



**1、堆内存溢出**（**outOfMemoryError：java heap space**）

​       在jvm规范中，堆中的内存是用来生成对象实例和数组的。

​       如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。

​       当生成新对象时，内存的申请过程如下：

​          a、jvm先尝试在eden区分配新建对象所需的内存；

​          b、如果内存大小足够，申请结束，否则下一步；

​          c、jvm启动youngGC，试图将eden区中不活跃的对象释放掉，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；

​          d、Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区；

​          e、 当OLD区空间不够时，JVM会在OLD区进行full GC；

​          f、full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”：

​                                   outOfMemoryError：java heap space

**2、方法区内存溢出**（**outOfMemoryError：permgem space**）

​       在jvm规范中，方法区主要存放的是类信息、常量、静态变量等。

​       所以如果程序**加载的类过多，或者使用反射、gclib**等这种动态代理生成类的技术，就可能导致该区发生内存溢出，一般该区发生内存溢出时的错误信息为：

​             outOfMemoryError：permgem space

**3、线程栈溢出**（**java.lang.StackOverflowError**）

​       线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。

​       一般线程栈溢出是由于**递归太深或方法调用层级过多**导致的。

​       发生栈溢出的错误信息为：

​              java.lang.StackOverflowError

**五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议：**

1、尽早释放无用对象的引用

2、使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域

3、尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收

4、避免在循环中创建对象

5、开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。

# Java内存溢出问题的定位过程 

对于java.lang.OutOfMemoryError: PermGen space 这种情况更多的是靠程序猿的经验来解决： 

   PermGen space的全称是Permanent Generation space,是指内存的永久保存区域, 这块内存主要是被JVM存放Class和Meta信息的,Class在被Load时就会被放到PermGen space中, 它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对 PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误。 

   通过上面的描述就可以得出：如果要加载的class与jar文件大小超过-XX:MaxPermSize就有可能会产生java.lang.OutOfMemoryError: PermGen space 。 

   换句话说-XX:MaxPermSize的大小要超过class与jar的大小。通常-XX:MaxPermSize为-Xmx的1/8。 

   对于java.lang.OutOfMemoryError: Java heap space 可能定位的过程就需要折腾一翻了：

   虽然各种java虚拟机的实现机制不一,但是heap space内存溢出产生的原因相同：那就是堆内存不够虚拟机分配了。 

   问题的关键就找到了，当产生heap space内存溢出时，堆内存中对象数量过多的就可能是问题的根源了。例外的情况是，程序确实需要那么多内存，这时就要考虑增大堆内存。 

   例外的情况在本文中就不再多说了，下面介绍jdk自带的两个可视化工具来定位问题。 

jdk/jconsole.exe  jdk/jvisualvm.exe 

   jconsole.exe可以查看本地以及远程主机上的java虚拟机的当前状况，这对服务器健康检查情况非常有用。如下图： 

![](D:\workspace\Github\node\瑞秋\201\assets/526008ac-853a-3309-9d31-cc4190ebf6f5.jpg)

​    jvisualvm.exe可以用来查看分析内存转储文件；也可以用其做java虚拟机当前状况查看，但是jvisualvm.exe的侵入性非常强，一旦使用会严重影响应用性能。如下图： 

![](D:\workspace\Github\node\瑞秋\201\assets/d076aabd-b6b2-39cf-a7b5-ffc582f95273.jpg)

  下面写些代码来演示一下内存溢出的产生，堆转储文件的生成，堆内存的分析。 

  首先创建数据持有对象类： 

```
package com.zas.jvm.om;

/**
 * 数据对象
 * @author zas
 */
public class DataObject {
	//数据对象ID
	private String id;
	//数据对象内容
	private String des;
	
	public DataObject(String id, String des) {
		super();
		this.id = id;
		this.des = des;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getDes() {
		return des;
	}

	public void setDes(String des) {
		this.des = des;
	}

	@Override
	public String toString() {
		return "DataObject [id=" + id + ", des=" + des + "]";
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {

	}
}
```

溢出演示代码 

```
package com.zas.jvm.om;

import java.util.ArrayList;
import java.util.List;

public class OutMemeryTest {
	
	List<DataObject> list = new ArrayList<DataObject>();
	
	public void testOm(){
		for (int i = 0; i < 100000; i++) {
			DataObject data = new DataObject("id&"+i, "des:"+i);
			list.add(data);
		}
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		OutMemeryTest omt = new OutMemeryTest();
		for (int i = 0; i < 2; i++) {
			omt.testOm();
		}
		System.out.println("DOne!");
		try {
			Thread.sleep(100000000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```

 

运行参数设置如下：-Xms64m -Xmx64m -XX:PermSize=8m -XX:MaxPermSize=8m 

-XX:-HeapDumpOnOutOfMemoryError           

见下图： 

![](D:\workspace\Github\node\瑞秋\201\assets/a2e277bc-6b46-3c78-8645-3359cc3192a7.jpg)

jvisualvm分析效果图： 

![](D:\workspace\Github\node\瑞秋\201\assets/2f64116e-3cbd-32ea-be30-be0ea00dc6b7.jpg)

从上图结合代码明显得出：com.zas.jvm.om.DataObject这个类的对象出了问题。 

以上是一个演示问题产生及定位过程，生产环境的问题千奇百怪需要具体问题具体分析。 

当堆内存巨大时可能要调整jdk\lib\visualvm\etc\visualvm.conf文件中的-xms -xmx大小来导入转储文件。 

生产环境为linux的较多，可以借助jdk自带的jmap来转储堆内存文件来分析。



#### 持久代空间

​       当Java虚拟机需要加载定义的一个新class，但是在持久代中没有足够的空间就会抛出‘Java.Lang.OutOfMemoryError: PermGen Space’异常。默认分配给持久代的大小在server模式下是64MB ，在client模式下是32MB 。这就有两个原因可能会引起持久代内存溢出问题的发生。

第一个原因可能是你应用或者服务器已经有非常多的class在你的持久代中，已经不能容纳所有的class了。

## -XX:MaxPermSize=XXXM

​        如果是因为大量的class导致持久代的空间的不足引起的问题，那么你可以增加持久代的大小通过–XX:MaxPermSize=XXm  参数。这将增加持久代的可用空间来保存class。看起来像这样： -XX:MaxPermSize=256m

## -XX:+CMSClassUnloadingEnabled

​       这个参数表示在使用CMS垃圾回收机制的时候是否启用类卸载功能。默认这个是设置为不启用的，所以你想启用这个功能你需要在Java参数中明确的设置下面的参数：

-XX:+CMSClassUnloadingEnabled

如果你启用了CMSClassUnloadingEnabled ，垃圾回收会清理持久代，移除不再使用的classes。这个参数只有在 [UseConcMarkSweepGC](http://stas-blogspot.blogspot.in/2011/07/most-complete-list-of-xx-options-for.html#UseConcMarkSweepGC) 也启用的情况下才有用。参数如下：

-XX:+UseConcMarkSweepGC

## -XX:+CMSPermGenSweepingEnabled

​       这个参数表示是否会清理持久代。默认是不清理的，因此我们需要明确设置这个参数来调试持久代内存溢出问题。这个参数在Java6中被移除了，因此你需要使用 -XX:+CMSClassUnloadingEnabled 如果你是使用Java6或者后面更高的版本。那么解决持久代内存大小问题的参数看起来会是下面这样子：

-XX:MaxPermSize=128m -XX:+UseConcMarkSweepGC XX:+CMSClassUnloadingEnabled

## 内存泄露

​     第二个原因可能是内存泄露。那么加载的类怎样变成不用的呢？

​     在Java中通常class是永久存在的。一旦class被加载，他们就呆在内存中，即使服务器上的应用停掉了。像cglib这样可以动态产生class的类库会使用很多持久代空间，因为它动态的创建很多class。频繁的使用在运行时创建的代理类。当一个类定义可以为多个实例重用时很容易创建新的代理类。

​       Sping和Hibernate经常会代理某些class。这些代理的class是通过类加载器加载的。产生的类定义如果一直不回收就会导致持久代空间很快就满了。

​       你需要确定是不是内存泄露引起的持久代空间的问题，同时解决它。增加持久代空间大小将不会有用，这只会延迟它的发生，因为在某个时间点持久代还是会被填满。

# java中的四种引用类型:

- **强引用(StrongReference)**：JVM 宁可抛出 OOM ,也不会让 GC 回收具有强引用的对象;

如:User u=new User(); 
User u 存在于栈里面,new User() 存在于堆里面的,栈通过 = 号,将堆对象引用起来,叫强引用(当前这种形式称为显式的强引用(强可及对象))

- **软引用(SoftReference)**：只有在内存空间不足时，才会被回的对象；
- **弱引用(WeakReference)**：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；
- **虚引用(PhantomReference)**：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。

> **软引用和弱引用，这两个引用是可以随时被虚拟机回收的对象，我们将一些比较占内存但是又可能后面用的对象，比如Bitmap对象，可以声明为软引用或弱引用。但是注意一点，每次使用这个对象时候，需要显示判断一下是否为null，以免出错。**



# Java内存模型JMM

## 关于并发编程

在并发编程领域，有两个关键问题：线程之间的**通信**和**同步**。

### 线程之间的通信

线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种**共享内存**和**消息传递**。

在**共享内存**的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过**共享对象**进行通信。

在**消息传递**的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是**wait()**和**notify()**。

### 线程之间的同步

同步是指程序用于控制不同线程之间操作发生相对顺序的机制。

在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。

### Java的并发采用的是共享内存模型

Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。

## Java内存模型

上面讲到了Java线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，**JMM决定一个线程对共享变量的写入何时对另一个线程可见**。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本**。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

![](D:\workspace\Github\node\瑞秋\201\assets/20160921182337904.png)

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

```
1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 
```

下面通过示意图来说明这两个步骤： 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921182748551.png)

如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

上面也说到了，Java内存模型只是一个抽象概念，那么它在Java中具体是怎么工作的呢？为了更好的理解上Java内存模型工作方式，下面就JVM对Java内存模型的实现、硬件内存模型及它们之间的桥接做详细介绍。

### JVM对Java内存模型的实现

在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区，下图展示了Java内存模型在JVM中的逻辑视图： 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921182837697.png)
==**JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。**==

==**线程栈还包含了当前方法的所有本地变量信息。一个线程只能读取自己的线程栈，也就是说，线程中的本地变量对其它线程是不可见的。即使两个线程执行的是同一段代码，它们也会各自在自己的线程栈中创建本地变量，因此，每个线程中的本地变量都会有自己的版本。**==

==**所有原始类型(boolean,byte,short,char,int,long,float,double)的本地变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的本地变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。**==

==**堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。**==

下图展示了调用栈和本地变量都存储在栈区，对象都存储在堆区： 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921182903818.png)
==**一个本地变量如果是原始类型，那么它会被完全存储到栈区。**== 
==**一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。**==

**==对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。==** 
==**对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。**==

==**Static类型的变量以及类本身相关信息都会随着类本身存储在堆区。**==

**==堆中的对象可以被多线程共享。如果一个线程获得一个对象的引用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。==**

下图展示了上面描述的过程: 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921182948601.png)

### 硬件内存架构

不管是什么内存模型，最终还是运行在计算机硬件上的，所以我们有必要了解计算机硬件内存架构，下图就简单描述了当代计算机硬件内存架构： 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921183013570.png)

现代计算机一般都有2个以上CPU，而且每个CPU还有可能包含多个核心。因此，如果我们的应用是多线程的话，这些线程可能会在各个CPU核心中并行运行。

==**在CPU内部有一组CPU寄存器，也就是CPU的储存器。CPU操作寄存器的速度要比操作计算机主存快的多。在主存和CPU寄存器之间还存在一个CPU缓存，CPU操作CPU缓存的速度快于主存但慢于CPU寄存器。某些CPU可能有多个缓存层（一级缓存和二级缓存）。计算机的主存也称作RAM，所有的CPU都能够访问主存，而且主存比上面提到的缓存和寄存器大很多。**==

==**当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存，进而在读取CPU缓存到寄存器。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后再在某些节点把缓存数据flush到主存。**==

### Java内存模型和硬件架构之间的桥接

正如上面讲到的，Java内存模型和硬件内存架构并不一致。硬件内存架构中并没有区分栈和堆，从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，当然一部分栈和堆的数据也有可能会存到CPU寄存器中，如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系： 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921183144995.png)
当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：

```
1. 共享对象对各个线程的可见性
2. 共享对象的竞争现象
```

#### 共享对象的可见性

当多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见。

想象一下我们的共享对象存储在主存，一个CPU中的线程读取主存数据到CPU缓存，然后对共享对象做了更改，但CPU缓存中的更改后的对象还没有flush到主存，此时线程对共享对象的更改对其它CPU中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中。

下图展示了上面描述的过程。左边CPU中运行的线程从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在右边CPU中的线程不可见，因为这个更改还没有flush到主存中： 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921183218651.png)
要解决共享对象可见性这个问题，我们可以使用java volatile关键字。 **==Java’s volatile keyword. volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存。==**volatile原理是基于CPU内存屏障指令实现的，后面会讲到。

#### 竞争现象

如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。

如下图所示，线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。

如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作。 
![](D:\workspace\Github\node\瑞秋\201\assets/20160921183251870.png)

要解决上面的问题我们可以使用java synchronized代码块。**==synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。==**



## 支撑Java内存模型的基础原理

### 指令重排序

在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的`Memory Barrier`来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。

1. 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

#### 数据依赖性

如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 
编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

#### as-if-serial

不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。

### 内存屏障（Memory Barrier ）

上面讲到了，通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：

1. 保证特定操作的执行顺序。
2. 影响某些数据（或则是某条指令的执行结果）的内存可见性。

**编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。**

**Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个`Write-Barrier`（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。**

这和java有什么关系？上面java内存模型中讲到的volatile是基于Memory Barrier实现的。

如果一个变量是`volatile`修饰的，JMM会在写入这个字段之后插进一个`Write-Barrier`指令，并在读这个字段之前插入一个`Read-Barrier`指令。这意味着，如果写入一个`volatile`变量，就可以保证：

1. 一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
2. 在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。

### happens-before

从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。

在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。

与程序员密切相关的happens-before规则如下：

1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
2. 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
3. volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
4. 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。

注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。

happens-before是JMM定义的2个操作之间的偏序关系：如果操作A线性发生于操作B，则A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。如果两个操作满足happens-before原则，那么不需要进行同步操作，JVM能够保证操作具有顺序性，此时不能够随意的重排序。否则，无法保证顺序性，就能进行指令的重排序。

happens-before原则主要包括：

- 程序次序规则(Program Order Rule)：在**同一个线程**中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操纵。准确的说是程序的控制流顺序，考虑分支和循环等。
- 管理锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面（时间上的顺序）对**同一个锁**的lock操作。
- volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对该变量的读操作。
- 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终止规则(Thread Termination Rule)：线程的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时事件的发生。Thread.interrupted()可以检测是否有中断发生。
- 对象终结规则(Finilizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()的开始。
- 传递性(Transitivity)：如果操作A 先行发生于操作B，操作B 先行发生于操作C，那么可以得出A 先行发生于操作C。

**注意：不同操作时间先后顺序与先行发生原则之间没有关系，二者不能相互推断，衡量并发安全问题不能受到时间顺序的干扰，一切都要以happens-before原则为准**





### **1.6、设计模式**

- 常见的设计模式
- 设计模式的的六大原则及其含义
- 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式
- 设计模式在实际场景中的应用
- Spring中用到了哪些设计模式
- MyBatis中用到了哪些设计模式
- 你项目中有使用哪些设计模式
- 说说常用开源框架中设计模式使用分析
- 动态代理很重要！！！

**1.7、数据结构**

- 树（二叉查找树、平衡二叉树、红黑树、B树、B+树）
- 深度有限算法、广度优先算法
- 克鲁斯卡尔算法、普林母算法、迪克拉斯算法
- 什么是一致性Hash及其原理、Hash环问题
- 常见的排序算法和查找算法：快排、折半查找、堆排序等

### 1.网络/IO基础

# BIO、NIO、AIO的概念

BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。 

NIO(reactor模型)：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。 

AIO(proactor模型)：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。 









- 什么是长连接和短连接
- Http1.0和2.0相比有什么区别，可参考《[Http 2.0](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484611&idx=1&sn=66c875392eedff8150633ddcd5d83e7a&chksm=e9c5fd72deb274648a607b9bc39bac34adadd768577b77354f6dc85422691605e210b69eeb7b&scene=21#wechat_redirect)》
- Https的基本概念
- 三次握手和四次挥手、为什么挥手需要四次
- 从游览器中输入URL到页面加载的发生了什么？可参考《[从输入URL到页面加载发生了什么](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483724&idx=1&sn=e58dd30d124971c795584e8673d6cc71&chksm=e9c5f8fddeb271ebebbb6c350ed1abc252f1f26b4f35c4ce36e10bde9659a37520feabed2290&scene=21#wechat_redirect)》

**二、数据存储和消息队列**

### **2.1、数据库**

- MySQL 索引使用的注意事项
- DDL、DML、DCL分别指什么
- explain命令
- left join，right join，inner join
- 数据库事物ACID（原子性、一致性、隔离性、持久性）
- 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）
- 脏读、幻读、不可重复读
- 数据库的几大范式
- 数据库常见的命令
- 说说分库与分表设计
- 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）
- 说说 SQL 优化之道
- MySQL遇到的死锁问题、如何排查与解决
- 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景
- 索引类别（B+树索引、全文索引、哈希索引）、索引的原理
- 什么是自适应哈希索引（AHI）
- 为什么要用 B+tree作为MySQL索引的数据结构
- 聚集索引与非聚集索引的区别
- 遇到过索引失效的情况没，什么时候可能会出现，如何解决
- limit 20000 加载很慢怎么解决
- 如何选择合适的分布式主键方案
- 选择合适的数据存储方案
- 常见的几种分布式ID的设计方案
- 常见的数据库优化方案，在你的项目中数据库如何进行优化的

### **2.2、Redis**

- Redis 有哪些数据类型，可参考《[Redis常见的5种不同的数据类型详解](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483987&idx=1&sn=5c5e4cd5bc73a7e6f84e5d6adfab0935&chksm=e9c5fbe2deb272f4b5b75bd2ac92bb27950452623ec83c0e1add7e30c773160421fab1571680&scene=21#wechat_redirect)》
- Redis 内部结构
- Redis 使用场景
- Redis 持久化机制，可参考《[使用快照和AOF将Redis数据持久化到硬盘中](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483992&idx=1&sn=8f554bc490c4db1a78a30144f873e911&chksm=e9c5fbe9deb272fff47483c241e6d2a7aae99dc8f6fe9fee31f2dd214d0cf81b33d51f7a7dbe&scene=21#wechat_redirect)》
- Redis 集群方案与实现
- Redis 为什么是单线程的？
- 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级
- 使用缓存的合理性问题
- Redis常见的回收策略

### **2.3、消息队列**

- 消息队列的使用场景
- 消息的重发补偿解决思路
- 消息的幂等性解决思路
- 消息的堆积解决思路
- 自己如何实现消息队列
- 如何保证消息的有序性

## **三、开源框架和容器**

### **3.1、SSM/Servlet**

- Servlet的生命周期
- 转发与重定向的区别
- BeanFactory 和 ApplicationContext 有什么区别
- Spring Bean 的生命周期
- Spring IOC 如何实现
- Spring中Bean的作用域，默认的是哪一个
- 说说 Spring AOP、Spring AOP 实现原理
- 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择
- Spring 事务实现方式、事务的传播机制、默认的事务类别
- Spring 事务底层原理
- Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《[JDK动态代理给Spring事务埋下的坑！](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484940&idx=1&sn=0a0a7198e96f57d610d3421b19573002&chksm=e9c5ffbddeb276ab64ff3b3efde003193902c69acda797fdc04124f6c2a786255d58817b5a5c&scene=21#wechat_redirect)》
- 如何自定义注解实现功能
- Spring MVC 运行流程
- Spring MVC 启动流程
- Spring 的单例实现原理
- Spring 框架中用到了哪些设计模式
- Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）
- 有没有用到Spring Boot，Spring Boot的认识、原理
- MyBatis的原理
- 可参考《[为什么会有Spring](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484822&idx=1&sn=6fbee2a12b31b6102a18d3725671d41b&chksm=e9c5fc27deb275319641c3f30d168b85c7c196fd276d47efa35046b5dc54f5b77174c5bf8808&scene=21#wechat_redirect)》
- 可参考《[为什么会有Spring AOP](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484827&idx=1&sn=b9d82f3fced6a875f8dfc22e5849b28e&chksm=e9c5fc2adeb2753c516ef8fc959c0c9dd84ccacaa40473b64bc58b5137c30562a0b45803ba8e&scene=21#wechat_redirect)》

### **3.2、Netty**

- 为什么选择 Netty
- 说说业务中，Netty 的使用场景
- 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
- 什么是TCP 粘包/拆包
- TCP粘包/拆包的解决办法
- Netty 线程模型
- 说说 Netty 的零拷贝
- Netty 内部执行流程
- Netty 重连实现

**3.3、Tomcat**

- Tomcat的基础架构（Server、Service、Connector、Container）
- Tomcat如何加载Servlet的
- Pipeline-Valve机制
- 可参考：《[四张图带你了解Tomcat系统架构](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484905&idx=1&sn=6c8acd89476fadbc4cb9ccfda9c9c2e4&chksm=e9c5fc58deb2754e7519511bb0ed8dcbfa3fe29179663b53f3626643f8b9c82068d9b0464ee6&scene=21#wechat_redirect)！》

## **四、分布式**

## **4.1、Nginx**

- 请解释什么是C10K问题或者知道什么是C10K问题吗？
- Nginx简介，可参考《[Nginx简介](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483994&idx=1&sn=b6591f62c7ea6b4adc5a5bf1bf4eac40&chksm=e9c5fbebdeb272fdd865a9c61a380f6b909fc988f99d00ce0aa8c3efca501644db46c40bd4f2&scene=21#wechat_redirect)》
- 正向代理和反向代理.
- Nginx几种常见的负载均衡策略
- Nginx服务器上的Master和Worker进程分别是什么
- 使用“反向代理服务器”的优点是什么?

### **4.2、分布式其他**

- 谈谈业务中使用分布式的场景
- Session 分布式方案
- Session 分布式处理
- 分布式锁的应用场景、分布式锁的产生原因、基本概念
- 分布是锁的常见解决方案
- 分布式事务的常见解决方案
- 集群与负载均衡的算法与实现
- 说说分库与分表设计，可参考《[数据库分库分表策略的具体实现方案](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483931&idx=1&sn=6eda41aa81c1243422a603205d2fad22&chksm=e9c5fbaadeb272bc92537803c14a6f55e1170b1a3b8f60160f66417800c0ace960dfe192717a&scene=21#wechat_redirect)》
- 分库与分表带来的分布式困境与应对之策

**4.3、Dubbo**

- 什么是Dubbo，可参考《[Dubbo入门](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483791&idx=1&sn=49345f1a022734e81e9257f2b8d38a52&chksm=e9c5f83edeb2712805a77c1e1589e8f1d04bd17e55eeb2a45cabddb46d03615636908f058628&scene=21#wechat_redirect)》
- 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《[基于HTTP的RPC实现](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483900&idx=1&sn=c5ca198a66a701f81c2ab118fe7a734a&chksm=e9c5f84ddeb2715bc574e467cd6537ef81f223453e0989ffd136976b48dcc2d961a75be596de&scene=21#wechat_redirect)》
- Dubbo中的SPI是什么概念
- Dubbo的基本原理、执行流程

**五、微服务**

**5.1、微服务**

- 前后端分离是如何做的？
- 微服务哪些框架
- Spring Could的常见组件有哪些？可参考《[Spring Cloud概述](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484125&idx=1&sn=ddba9fba6ae900f5ef71a68f70afebe5&chksm=e9c5fb6cdeb2727a1e8d16a05adb7d9df0170e392ae579d1e40075fb488d680f0c061aa45327&scene=21#wechat_redirect)》
- 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型
- JWT有了解吗，什么是JWT，可参考《[前后端分离利器之JWT](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485183&idx=1&sn=05dac824dbb534710dd99d6c895fbaf5&chksm=e9c5ff4edeb27658173c8b06ad6d1241d3b7822c734ddf6ac064d40e63cb0cb0a0c90804b9c7&scene=21#wechat_redirect)》
- 你怎么理解 RESTful
- 说说如何设计一个良好的 API
- 如何理解 RESTful API 的幂等性
- 如何保证接口的幂等性
- 说说 CAP 定理、BASE 理论
- 怎么考虑数据一致性问题
- 说说最终一致性的实现方案
- 微服务的优缺点，可参考《[微服务批判](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485005&idx=1&sn=78a1d286c6a15a81ea5dcf6634a70b54&chksm=e9c5fffcdeb276ea3c766a6e5954685db0e89bea8ff0f47c9a3ff2c0c02991f791a5160287c4&scene=21#wechat_redirect)》
- 微服务与 SOA 的区别
- 如何拆分服务、水平分割、垂直分割
- 如何应对微服务的链式调用异常
- 如何快速追踪与定位问题
- 如何保证微服务的安全、认证

### **5.2、安全问题**

- 如何防范常见的Web攻击、如何方式SQL注入
- 服务端通信安全攻防
- HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比

### **5.3、性能优化**

- 性能指标有哪些
- 如何发现性能瓶颈
- 性能调优的常见手段
- 说说你在项目中如何进行性能调优

## **六、其他**

### **6.1、设计能力**

- 说说你在项目中使用过的UML图
- 你如何考虑组件化、服务化、系统拆分
- 秒杀场景如何设计
- 可参考：《[秒杀系统的技术挑战、应对策略以及架构设计总结一二！](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485294&idx=1&sn=681b3fc8833bc978344f66c8dd33ff32&chksm=e9c5fedfdeb277c96e03e8943bff709ad5354cbbe0c0d894cdb9d1e8cc8da92bf51f1e832e37&scene=21#wechat_redirect)》

### **6.2、业务工程**

- 说说你的开发流程、如何进行自动化部署的
- 你和团队是如何沟通的
- 你如何进行代码评审
- 说说你对技术与业务的理解
- 说说你在项目中遇到感觉最难Bug，是如何解决的
- 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方

### **6.3、软实力**

- 说说你的优缺点、亮点
- 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码
- 说说你觉得最有意义的技术书籍
- 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力
- 说说个人发展方向方面的思考
- 说说你认为的服务端开发工程师应该具备哪些能力
- 说说你认为的架构师是什么样的，架构师主要做什么
- 如何看待加班的问题

当然，一个完整的面试肯定不止上述的知识点，其他的诸如：Linux、数据结构、算法、逻辑思维题、系统设计题、职业规划等等都会有所涉及！总之，充分的准备是应对一切面试的不二法宝！