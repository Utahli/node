## **一、基础篇**

### **1.1、Java基础**

#### 面向对象的特征：继承、封装和多态



**什么是封装？**
==信息隐藏，指利用抽象数据类型将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型的内部，隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过这些接口与这个封装的对象进行交互。==
**封装的好处：**
1、使调用者正确、方便的使用系统功能，防止调用者随意修改系统属性。
2、提高组件的重用性；
3、良好的封装能够减少耦合（当某一个模块实现发生变化时，只要对外暴露的接口不变，就不会影响到其他模块）。
**封装如何暴露和隐藏呢？访问权限控制：**
private:表示私有的，表示类访问权限，只能在本类中访问，离开本类之后，就不能直接访问；
不写(缺省)：表示包私有，表示包访问权限，访问者的包必须和当前定义类的包相同才能访问；
protected：表示子类访问权限，同包中的可以访问，即使不同包，但是有继承关系，也可以访问；

public：表示全局的，可以公共访问权限，如果某个字段/方法使用了public修饰，则可以在当前项目中任何地方访问。



**什么是继承关系：**
 继承是使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以覆盖父类的某些特性。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。
继承是一种从一般到特殊的关系，是一种“is a”的关系，即子类是对父类的拓展
在Java中，类和类之间的继承关系**只允许单继承，不允许多继承。但是Java允许多重继承**。
在Java中除了Object类之外，每一个类都有一个直接的父类，
**继承关系的作用：**
1)解决了代码的重复问题；
2)**真正的作用，表示出一个体系。子类继承了父类的哪些成员（根据访问修饰符来判断）：**
1)如果父类中的成员使用public修饰，子类继承；
2)如果父类中的成员使用protected修饰，子类也继承，即使父类子类不在同一个包；
3)如果父类和子类在同一个包中，此时子类可以继承父类中缺省修饰符的成员；
4)如果父类中的成员使用private修饰，子类打死都继承不到，因为private只能在本类中访问；
5)父类的构造器，子类也不能访问，因为构造器必须和当前的类名相同。

==编译器会默认给子类调用父类的构造器==。

​    ==但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用指定的父类构造器，而且必须是在子类构造器中做的第一件事(第一行代码)否，则编译器会报错：无法找到符合父类形式的构造器。==

​    对于**子类**而言，==当且仅当只有一个**方法可以**在构造器中调用父类构造器来完成初始化**==。

==继承存在如下缺陷：==

==1、父类变，子类就必须变。==

==2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。==

==3、继承是一种强耦合关系。==



**多态：（当我们代码变成以下样子时，多态就产生了）**
==一个引用变量指向哪个类的实例对象，该引用变量发出的方法调用是哪个类中实现的方法，必须在由程序运行期间才能决定。在程序运行时所绑定的具体代码，让程序可以选择多个运行状态的特性，就是多态性。==

​    ==对于面向对象而言，多态分为**编译时多态**和**运行时多态**。其中**编辑时多态是静态的，主要是指方法的重载**，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而**运行时多态是动态的，它是通过动态绑定来实现的，它是真正的多态性。**==
**多态的前提：**可以是继承关系（类和类）/也可以是实现关系（接口和实现类），在开发中多态一般指第二种。
**多态的特点：**把子类对象赋给父类变量，在运行时期会表现出具体的子类特征。
**多态的作用：**当把不同的子类对象都当做父类类型来看待，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。

==Java实现多态有三个必要条件：继承、重写、向上转型。==

==对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用引用子类对象时，是被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。==

 **在Java中有两种形式可以实现多态：继承和接口。**

 **基于继承实现的多态**

​    ==基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为==。

​    基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。

​    如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。

 **基于接口实现的多态**

接口 Interface

​    继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。

​    在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

​    ==继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。==

 **继承链调用优先级**

==在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。==

**==当超类对象引用变量引用子类对象时，是被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，不过仍然要按照继承链中调用方法的优先级来确认。==**



#### 重载和重写的区别

- 重载overloading

  就是==一个类里有两个或更多名字相同而参数不同的函数==.==每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。==

- 覆写overriding

  ==发生在子类中！在子类中可以用自己的逻辑去实现继承的父类的方法==

==重载 静态捆绑 (static binding) 是 编译时多态==

==覆写 动态捆绑 (dynamic binding) 是 运行时多态==

==1、重载是一个编译期概念、重写是一个运行期间概念。==

==2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。==

==3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法==

==4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）==

==构造器不能被继承所以不能被 重写 但可以被重载（构造器名称与类名相同）==

==方法重载是**一个类的多态性表现**,而方法重写是子类与父类的一种多态性表现。==



#### final, finally, finalize 的区别

**1、final 修饰符（关键字）**

==final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量(在方法中的或者代码块中的变量称为本地变量) 。==

如果类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。 

将变量或者方法声明为final，可以保证他们在使用中不被改变。final成员变量的初始化可以在两个地方：一是其定义处，也就是说，在final变量定义时直接给其赋值；二是构造函数中。这2个地方只能选其一，要么在定义处直接给其赋值，要么在构造函数中给值，并且在以后的引用中，只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写。==final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。== 

**使用final关键字的好处**

1. ==final关键字提高了性能。JVM和Java应用都会缓存final变量。==
2. ==final变量、final类可以安全的在多线程环境下进行共享，而不需要额外的同步开销。==
3. 使用final关键字，JVM会对方法、变量及类进行优化。

 关于final的重要知识点

1. final关键字可以用于成员变量、本地变量、方法以及类。
2. ==final成员变量必须在**声明的时候初始化**或者**在构造器中初始化**，否则就会报编译错误。==
3. 你不能够对final变量再次赋值。
4. ==本地变量必须在声明时赋值。==
5. ==在匿名类中所有变量都必须是final变量。==
6. ==final方法不能被重写。==
7. ==final类不能被继承。==
8. final关键字不同于finally关键字，后者用于异常处理。
9. final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
10. ==接口中声明的所有变量本身是final的。==
11. ==final和abstract这两个关键字是反相关的，final类就不可能是abstract的。==
12. ==final方法在编译阶段绑定，称为静态绑定(static binding)。==
13. ==没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。==
14. 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
15. 按照Java代码惯例，final变量就是常量，而且通常常量名要大写

 **2、finally(用于异常处理)**

​     ==一般是用于异常处理中，提供finally块来执行任何的清除操作，finally结构使代码总会执行，不关有无异常发生。==

 ==finally在try,catch中可以有，可以没有。如果trycatch中有finally则必须执行finally快中的操作。====一般情况下，用于关闭文件的读写操作，或者是关闭数据库的连接等等。==

==**两种情况下finally语句是不会被执行的：**==

==**（1）try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行**==

==**（2）在try块中有System.exit(0);语句，System.exit(0);是终止Java虚拟机JVM的，JVM停止了，finally语句也不会被执行到。**==

==**finally块的语句在try或catch中的return语句执行之后返回之前执行，且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回** 。==

 **3、finalize（用于垃圾回收）**

finalize是方法名。它是Object类中定义的，因此，所有的类都继承了它。finalize()方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 使用finalize还需要注意一个事，调用super.finalize(); ==**一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象（JVM另起一个低优先级的线程去执行finalize()方法），所以有可能调用finalize()后，该对象又不需要被回收了**，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，==产生问题。 一般来说，不推荐使用finalize()方法，它跟析构函数不一样。 

 **final, finally, finalize的区别**

- final 是Java的一个保留的关键字，用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.
- finally 是异常处理语句结构的一部分，表示无论异常是否发生，都会执行finally块的内容 
- finalize 是Object类的一个方法，这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.



#### Exception、Error、运行时异常与一般异常有何异同

![](D:\workspace\Github\node\瑞秋\201\assets\20180309211054853.jpg)

Java对异常进行了分类，所有异常的根类为java.lang.Throwable

==Throwable下面又派生了两个子类：Error和Exception==

Error：表示由JVM所侦测到的无法预期的错误，由于这是属于JVM层次的严重错误，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 

**Error：表示由JVM所侦测到的无法预期的错误，描述了java运行时系统的内部错误和资源耗尽错误。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题，导致JVM无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。**

**Exception：表示可恢复的操作，这是可捕捉到的。 这个层次结构又分解为连个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。==划分两个分支的规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有没有问题，但由于像I/O错误这类异常导致的异常属于非运行时异常。==** 

==Java提供了两类主要的异常**:runtime exception和checked exception**。checked 异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。**这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误.**==

==但是另外一种异常：runtime exception，也称运行时异常，在编译的时候不需要检查 (checked)。包括运行时异常（RuntimeException）和派生于Error类的异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。==

==出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。==

 处理异常的方法

1. try catch.
2. throws.

这两种方法有什么区别

==第一种方法是自己处理异常.==

==第二种异常是把异常抛给调用这个方法的模块去处理.==

#### 请写出5种常见到的runtime exception

IndexOutOfBoundsException(下标越界异常) 

NullPointerException(空指针异常) 

ClassNotFoundException

NumberFormatException （String转换为指定的数字类型异常） 

ArithmeticException -（算术运算异常 如除数为0） 

ArrayStoreException - （向数组中存放与声明类型不兼容对象异常）

SecurityException -（安全异常）



#### int 和 Integer 有什么区别，Integer的值缓存范围

  (1）Ingeter是int的包装类，是一个类，int是基本类型 

（2）int的初值为0，Ingeter的初值为null。

（3）int 是在栈里创建的，Integer是在堆里创建的。栈里创建的变量要比在堆创建的速度快得多。

（1）Integer参与数学运算时，会自动拆箱。

（2）Integer（常量池中）和new Integer对象（堆中）相比，地址永远不相等。

（3）两个非new的Integer对象相比，在-128~127中进行缓存，这个范围则相等。

（4）两个都是new出来的Integer永远不相等，在堆中的两个不同地址。

（5）Integer作为一个类，作为方法参数传递时，传递的还是值，而不是地址。

   (6）在==比较时只会经历拆箱过程，在=赋值时会出现拆箱和装箱过程。 

[-128,127]

#### 包装类，装箱和拆箱

Java语言是一个面向对象的语言，但**Java中的基本数据类型却是不面向对象**的，这在实际使用时存在很多的不便，为解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，**这样八个和基本数据类型对应的类统称为包装类****(Wrapper Class)**，也译为外覆类或数据类型类。==所有的包装类都是抽象类Number的子类。包装类均位于java.lang包。==

==对于包装类说，这些类的用途主要包含两种：==

​== a、作为和基本数据类型对应的类类型存在，**方便涉及到对象的操作**。==

==b、包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。==

==**装箱**： 可以自动将基本类型直接转换成对应的包装类型。 **拆箱**： 自动将包装类型转换成对应的基本类型值；==

装箱拆箱是通过调用`Integer.valueOf()`（装箱） 和 `Integer.initValue()`（拆箱）来完成的。

装箱操作会判断基本类型值是否在`IntegerCache.cache`数组范围内，如果在，返回`IntegerCache.cache`数组中对应下标的元素。否则，才新建一个对象。

==`IntegerCache.cache`是一个final的Integer数组，这个数组存储的Integer对象元素的值范围是[-128，127]。而且这个数组的初始化代码是包裹在static代码块中，也就是说`IntegerCache.cache`**数组的初始化是在类加载时完成的。**==

- ==包装类与String类很相似，都是非可变类，即一经创建后，便不可以修改。正因为这种特性，两者的对象实例在多线程下是安全的，不用担心异步修改的情况，这为他们实现共享提供了很好的保证，只需创建一个对象共享便可。==
- ==包装类的共享实现并不是由JVM来维护一个常量池，而是使用了缓存机制（数组），而且这个缓存是在类加载时完成初始化，并且不可再修改。==
- ==包装类的数组缓存范围是有限，只缓存基本类型值在一个字节范围内，也就是说 -128 ~ 127。（Character的范围是 0~127）==
- ==目前并不是所有包装类都提供缓存机制，只有Byte、Character、Short、Integer 4个包装类提供，Long、Float、Double 不提供。==



#### String、StringBuilder、StringBuffer

三者之间的区别：

==都是final类，都不允许被继承；==

==String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；==

==StringBuffer类是线程安全的，StringBuilder不是线程安全的；==

#### String 和 StringBuffer：

1、String类型和StringBuffer类型的主要性能区别：==String是不可变的对象，因此每次在对String类进行改变的时候都会生成一个新的string对象，然后将指针指向新的string对象，==所以经常要改变字符串长度的话不要使用string，因为每次生成对象都会对系统性能产生影响，特别是当内存中引用的对象多了以后，JVM的GC就会开始工作，性能就会降低；

2、==使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用，==所以多数情况下推荐使用StringBuffer，特别是字符串对象经常要改变的情况；

3、====**在运行期间，String字符串通过 + 来链接的表达式计算都是通过创建StringBuilder来完成的**==

==**String 在克隆时只是克隆了它的引用。**==

==String的equals方法 ： **先比较引用是否相同(是否是同一对象)，再检查是否为同一类型（str instanceof String）， 最后比较内容是否一致（String 的各个成员变量的值或内容是否相同）。这也同样适用于诸如 Integer 等的八种包装器类。==

**对于String类型的字面常量，必须要在 字符串常量池 中维护一个全局的引用。当遇到字符串常量时要先去字符串池中寻找是否存在这个常量，如果有，则返回对应的引用。如果没有，则创建对象并添加到字符串常量池中，然后返回新创建对象的引用。**

 **字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的**



#### 抽象类和接口有什么区别

**接口和抽象类都是继承树的上层，他们的共同点如下：**
1)	都是上层的抽象层。
2)	都不能被实例化
3)	都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现。

**他们的区别如下：**
1)	在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2)	一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。

3）实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现

4） ==抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。==

5）抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。==**抽象类是对类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。**

 6）==跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可；但是接口不同，实现它的子类可以不存在任何关系抽象类所体现的是一种继承关系，父类和派生类之间是"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。==

7） ==设计层次不同。对于抽象类而言，它是自底向上设计的，我们要先知道子类才能抽象出父类，而接口则不同，它自顶向下设计的，接口根本就不需要知道子类的存在，只需要定义一个规则即可，至于有什么子类、什么时候怎么实现它一概不知。==

 **四、总结**

​      ==1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。==

==​      2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。==

​==      3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。==

​	Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。

​	接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。
对于已经存在的继承树，可以方便的从类中抽象出新的接口，但是从类中抽象出新的抽象类就不那么容易了，因此接口更有利于软件系统的维护和重构。

 **一、抽象类**

抽象类是用来描述抽象行为的，体现了数据抽象的思想，是实现多态的一种机制。为其子类提供一个公共的类型，封装子类中得重复内容（成员变量和方法），子类虽然有不同的实现，但是定义是一致的。抽象方法的具体表现形式由子类来实现。

 **二、接口**

​      接口是抽象方法的集合，且不能实例化，没有构造体，所有方法都是抽象的 (abstract).同时也是隐式的 public. 也就是说声明时, 可以省略 public abstract，只能含有声明为 final static 的属性  。

JAVA的类可以被实现许多个接口，然而一个接口则无法实现其他的接口。

​	Java接口本身没有任何实现，因为Java接口不涉及表象，而只描述public行为，所以Java接口比Java抽象类更抽象化。但是接口不是类，不能使用new 运算符实例化一个接口。 

​      接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。

​      **在使用接口过程中需要注意如下几个问题：**

​         1、1个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！

​         2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。

​         3、==接口中不存在实现的方法。==

​         4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。

​         5、==不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。==

​         6、在实现多接口的时候一定要避免方法名的重复。



#### equals与==的区别

- **== 比较引用的地址**
- **equel 比较引用的内容** (Object 类本身除外)



#### Java的平台无关性如何体现出来的

==在 Java 应用程序和操作系统之间有一个虚拟层—— JRE（Java运行环境），JRE由JVM和一下类库组成，JVM拥有自己的指令集，在运行时操作不同的内存区域，其主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，它是实现Java跨平台的核心。所有的Java程序首先会编译成.class类文件，类文件的组成包括 JVM 指令集，符号表以及一些补助信息。 .class文件不直接与操作系统交互，而是由JRE里的JVM将程序解释给本地系统去执行，通过JVM间接的与操作系统交互，从而实现了Java程序的可移植性。== 



#### JDK和JRE的区别

==JRE是java运行环境。包含了JVM和JVM解释.class文件需要类库lib==

==JDK是Java环境的核心组件，并提供编译、调试和运行一个Java程序所需的所有工具，可执行文件和二进制文件。==

**JDK是用于java程序的开发,而jre则 是只能运行class而没有编译的功能。**

**JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。**

JVM 是 Java 平台的基础，是整个java实现跨平台的最核心的部分,它有自己的指令集，并且在运行时操作不同的内存区域，其主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或 OS 的系统调用，提供了一种与平台无关的代码执行方法。所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。

#### Java 8有哪些新特性



#### hashCode和equals方法的区别与联系

- 在Java中任何一个对象都具备equals(Object obj)和hashcode()这两个方法，因为他们是在Object类中定义的。  
- equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。  
- ==hashcode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。==  

关于这两个方法的重要规范：

==规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值==。

==规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。==

==**在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！**== 

==注意一下，String，Integer，Date这些类重写了equals()方法，不再是比较类在堆内存中的存放地址了。==



#### Object类中常见的方法，为什么wait  notify会放在Object里边？

**一.Object类中的toString()方法** 

==object 默认方法 toString方法，toString() 输出一个对象的地址字符串（哈希code码）！== 

**二.Object类中的equals()方法** 
==Object类equals()比较的是对象的引用是否指向同一块内存地址！== 

**Object()** 
默认构造方法 
**clone()** 
创建并返回此对象的一个副本。 
**finalize()** 
当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 
**getClass()** 
返回一个对象的运行时类。 
**hashCode()** 
返回该对象的哈希码值。 

**wait(),sleep()区别？** 
wait():释放资源，释放锁 
sleep():释放资源，不释放锁

**notify()** 
唤醒在此对象监视器上等待的单个线程。 
**notifyAll()** 
唤醒在此对象监视器上等待的所有线程。 
**wait()** 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 
**wait(long timeout)** 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 
**wait(long timeout, int nanos)** 
导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。

**为什么wait  notify会放在Object里边？(考点：线程通信机制)**

1. ==`wait`和`nofity`不是常见的普通java方法或同步工具，在Java中它们更多的是实现两个线程之间的通信机制。 如果不能通过类似`synchronized`这样的Java关键字来实现这种机制，那么`Object`类中就是定义它们最好的地方，以此来使任何Java对象都可以拥有实现线程通信机制的能力。记住`synchronized`和`wait`,`notify`是两个不同的问题域，并且不要混淆它们的相似或相关性。 同步类似竞态条件，是提供线程间互斥和确保Java类的线程安全性的，而`wait`和`notify`是两个线程之间的通信机制。==
2. ==每个对象都可以作为锁，这是另一个原因`wait`和`notify`在Object类中声明，而不是Thread类。==
3. ==在Java中，为了进入临界区代码段，线程需要获得锁并且它们等待锁可用，它们不知道哪些线程持有锁而它们只知道锁是由某个线程保持，它们应该等待锁而不是知道哪个线程在同步块内并要求它们释放锁。 这个比喻适合等待和通知在`object`类而不是Java中的线程。==



#### 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用

序列化：把对象转换为字节序列的过程称为对象的序列化。

反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

​        ==java对象序列化不仅保留一个对象的数据，而且**递归保存对象引用的每个对象的数据**。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的“深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象的序列。==

==**对象序列化保存的是对象的”状态”，即它的成员变量**。由此可知，对象序列化不会关注类中的静态变量。反之亦然。支持序列化和反序列化的基本类型有：String，Array，Enum和Serializable，如果非以上的一种，那么会抛出NotSerializableException异常。==

**==Externalizable进行序列化和反序列化会比较麻烦，因为需要重写序列化和反序列化的方法，序列化的细节需要手动完成。当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。因此，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。==** 

```java
public class User implements Externalizable {

    private String name;

    private transient String password;

    // 必须要有无参构造器
    public User() {
        System.out.println("constructor");
    }


    // 序列化User对象
    public void writeExternal(ObjectOutput out) throws IOException {
        System.out.println("writeExternal");
        out.writeObject(name);
        out.writeObject(password);
    }

    // 反序列化User对象
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        System.out.println("readExternal");
        name = (String) in.readObject();
        password = (String) in.readObject();
    }

    // 不会被执行
    private void writeObject(ObjectOutputStream out) throws IOException {
        System.out.println("writeObject");
    }

    // 不会被执行
    private void readObject(ObjectInputStream in) throws IOException {
        System.out.println("readObject");
    }

    // 在writeExternal之前执行，只是为了说明执行顺序，实际不需要写。
    private Object writeReplace() throws ObjectStreamException {
        this.setName("kobe");
        System.out.println("writeReplace");
        return this;
    }

    // 在readExternal之后执行，只是为了说明执行顺序，实际不需要写。
    private Object readResolve() throws ObjectStreamException {
        this.setName("kobe");
        System.out.println("readresolve");
        return this;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" +
                ", name='" + name + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```



==transient 修饰的属性，是不会被序列化的。==

==静态static的属性，不序列化。==

==**反序列化后类中static型变量为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的**==

==在序列化过程中，虚拟机会试图调用对象类里的writeObject() 和readObject()，进行用户自定义的序列化和反序列化，如果没有则调用ObjectOutputStream.defaultWriteObject() 和ObjectInputStream.defaultReadObject()。同样，在ObjectOutputStream和ObjectInputStream中最重要的方法也是writeObject() 和 readObject()，递归地写出/读入byte。==

==​        所以用户可以通过writeObject()和 readObject()自定义序列化和反序列化逻辑。对一些敏感信息加密的逻辑也可以放在此。【不过此处不会检查serialVersionUID】==

==方法writeObject处理对象的序列化。如果声明该方法，它将会被ObjectOutputStream调用而不是默认的序列化进程。如果你是第一次看见它，你会很惊奇尽管它们被外部类调用但事实上这是两个private的方法。并且它们既不存在于java.lang.Object，也没有在Serializable中声明。那么ObjectOutputStream如何使用它们的呢？这个吗，ObjectOutputStream使用了反射来寻找是否声明了这两个方法。因为ObjectOutputStream使用**getPrivateMethod**，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。== 

　　==在两个方法的开始处，你会发现调用了defaultWriteObject()和defaultReadObject()。它们做的是默认的序列化进程，就像写/读所有的non-transient和 non-static字段(但他们不会去做serialVersionUID的检查).通常说来，所有我们想要自己处理的字段都应该声明为transient。==

　1.==Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;== 

　　2.==Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。== 

**==我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。==**

==无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象。==

**==transient关键字是和Serializable默认序列化行为联系在一起的，同时也是和 ObjectOutputStream out.defaultWriteObject()，ObjectInputStream in.defaultReadObject() 这两个方法联系在一起的。在进行默认序列化操作，以及调用out.defaultWriteObject()和in.defaultReadObject()这两个方法进行序列化操作的时候，标注transient的变量会被序列化操作所忽略。除Serializable之外，transient关键字在其他地方不会起到任何作用。==**

**==Externalizable的优先级比Serializable的优先级要高。假如，某个类同时实现了两个接口，那么在序列化的时候只会考虑和Externalizable接口相关的性质，而不会考虑和Serializable相关的性质==。**



==序列化会通过反射调用无参数的构造方法创建一个新的对象。====如果实现了serializable 或者 externalizable接口的类中包含`readResolve`==，==那么这个方法会在反序列化完成之后被调用，实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象。==

==**writeObject:** 用来处理对象的序列化，如果声明该方法，它会被ObjectOutputStream调用，而不是默认的序列化进程；== 
==**readObject:** 和writeObject相对应，用来处理对象的反序列化。== 
==ObjectOutputStream使用**反射getPrivateMethod**来寻找默认序列化的类是否声明了这两个方法，所以这两个方法必须声明为private提供ObjectOutputStream使用。虚拟机会先试图调用对象里的writeObject, readObject方法，进行用户自定义序列化和反序列化，若没有这样的方法，就会使用默认的ObjectOutputSteam的defaultWriteObject及ObjectInputStream里的defaultReadObject方法。==



- 说说反射的用途及实现

- 说说自定义注解的场景及实现

- HTTP请求的GET与POST方式的区别

- Session与Cookie区别

- 列出自己常用的JDK包

- MVC设计思想

  

### **1.2、Java常见集合**

==迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历,Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。 Set 和List 都继承了Conllection。==

 Collection接口的方法（8个）：

```java
boolean add(Object o)      ：向集合中加入一个对象的引用   

void clear()：删除集合中所有的对象，即不再持有这些对象的引用   
  
boolean isEmpty()    ：判断集合是否为空   
   
boolean contains(Object o) ： 判断集合中是否持有特定对象的引用   

Iterartor iterator()  ：返回一个Iterator对象，可以用来遍历集合中的元素   
   
boolean remove(Object o) ：从集合中删除一个对象的引用   
   
int size()       ：返回集合中元素的数目   
   
Object[] toArray()    ： 返回一个数组，该数组中包括集合中的所有元素 </span> 
```

![1531329148160](D:\workspace\Github\node\瑞秋\LMS\assets\1531329148160.png)

### Iterator接口声明了如下方法：

```java
hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true   
  
next() ：返回下一个元素   
  
remove()：从集合中删除上一个有next()方法返回的元素。 
```

#### List 和 Set 区别

Set集合中的对象不按特定的方式排序，存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。 对Set的构造函数，传入的Collection参数不能包含重复的元素。

**HashSet是Set接口的典型实现，==HashSet使用HASH算法来存储集合中的元素（底层实现为HashMap），==因此具有良好的存取和查找性能。**
     值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等

 ==**LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。**==
　　当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。

==List的特征是其元素以线性方式存储，集合中可以存放重复对象。==

- Set和hashCode以及equals方法的联系
- List 和 Map 区别
- Arraylist 与 LinkedList 区别
- ArrayList 与 Vector 区别
- HashMap 和 Hashtable 的区别
- HashSet 和 HashMap 区别

   **HashSet是Set接口的典型实现，==HashSet使用HASH算法来存储集合中的元素（底层实现为HashMap），==因此具有良好的存取和查找性能。**
     值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等



- HashMap 和 ConcurrentHashMap 的区别
- HashMap 的工作原理及代码实现，什么时候用到红黑树
- 多线程情况下HashMap死循环的问题
- HashMap出现Hash DOS攻击的问题
- ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数
- 手写简单的HashMap
- 看过那些Java集合类的源码

**1.3、进程和线程**

- 线程和进程的概念、并行和并发的概念
- 创建线程的方式及实现
- 进程间通信的方式
- 说说 CountDownLatch、CyclicBarrier 原理和区别、Phaser 
- 说说 Semaphore 原理
- 说说 Exchanger 原理
- ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理
- 讲讲线程池的实现原理
- 线程池的几种实现方式
- 线程的生命周期，状态是如何转移的

### **1.4、锁机制**

#### 说说线程安全问题，什么是线程安全，如何保证线程安全

##### 产生线程不安全的原因

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化,多个线程读取相同的资源就是安全的。

**死锁**和**脏数据**就是典型的**线程安全**问题。

简单来说，线程安全就是： **在多线程环境中，能永远保证程序的正确性。**

只有存在**共享数据**时才需要考虑线程安全问题。

**方法区**和**堆**就是主要的线程共享区域。那么就是说共享对象只可能是类的属性域或静态域。 







- 重入锁的概念，重入锁为什么可以防止死锁
- 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）
- 如何检查死锁（通过jConsole检查死锁）
- volatile 实现原理（禁止指令重排、刷新内存）
- synchronized 实现原理（对象监视器）
- synchronized 与 lock 的区别
- AQS同步队列
- CAS无锁的概念、乐观锁和悲观锁
- 常见的原子操作类
- 什么是ABA问题，出现ABA问题JDK是如何解决的
- 乐观锁的业务场景及实现方式
- Java 8并法包下常见的并发类
- 偏向锁、轻量级锁、重量级锁、自旋锁的概念

### **1.5、JVM**

- JVM运行时内存区域划分
- 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决
- 如何判断对象是否可以回收或存活
- 常见的GC回收算法及其含义
- 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等
- JVM如何设置参数
- JVM性能调优
- 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的
- 类加载的过程：加载、验证、准备、解析、初始化
- 强引用、软引用、弱引用、虚引用
- Java内存模型JMM

### **1.6、设计模式**

- 常见的设计模式
- 设计模式的的六大原则及其含义
- 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式
- 设计模式在实际场景中的应用
- Spring中用到了哪些设计模式
- MyBatis中用到了哪些设计模式
- 你项目中有使用哪些设计模式
- 说说常用开源框架中设计模式使用分析
- 动态代理很重要！！！

**1.7、数据结构**

- 树（二叉查找树、平衡二叉树、红黑树、B树、B+树）
- 深度有限算法、广度优先算法
- 克鲁斯卡尔算法、普林母算法、迪克拉斯算法
- 什么是一致性Hash及其原理、Hash环问题
- 常见的排序算法和查找算法：快排、折半查找、堆排序等

### 1.网络/IO基础

- BIO、NIO、AIO的概念
- 什么是长连接和短连接
- Http1.0和2.0相比有什么区别，可参考《[Http 2.0](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484611&idx=1&sn=66c875392eedff8150633ddcd5d83e7a&chksm=e9c5fd72deb274648a607b9bc39bac34adadd768577b77354f6dc85422691605e210b69eeb7b&scene=21#wechat_redirect)》
- Https的基本概念
- 三次握手和四次挥手、为什么挥手需要四次
- 从游览器中输入URL到页面加载的发生了什么？可参考《[从输入URL到页面加载发生了什么](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483724&idx=1&sn=e58dd30d124971c795584e8673d6cc71&chksm=e9c5f8fddeb271ebebbb6c350ed1abc252f1f26b4f35c4ce36e10bde9659a37520feabed2290&scene=21#wechat_redirect)》

**二、数据存储和消息队列**

### **2.1、数据库**

- MySQL 索引使用的注意事项
- DDL、DML、DCL分别指什么
- explain命令
- left join，right join，inner join
- 数据库事物ACID（原子性、一致性、隔离性、持久性）
- 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）
- 脏读、幻读、不可重复读
- 数据库的几大范式
- 数据库常见的命令
- 说说分库与分表设计
- 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）
- 说说 SQL 优化之道
- MySQL遇到的死锁问题、如何排查与解决
- 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景
- 索引类别（B+树索引、全文索引、哈希索引）、索引的原理
- 什么是自适应哈希索引（AHI）
- 为什么要用 B+tree作为MySQL索引的数据结构
- 聚集索引与非聚集索引的区别
- 遇到过索引失效的情况没，什么时候可能会出现，如何解决
- limit 20000 加载很慢怎么解决
- 如何选择合适的分布式主键方案
- 选择合适的数据存储方案
- 常见的几种分布式ID的设计方案
- 常见的数据库优化方案，在你的项目中数据库如何进行优化的

### **2.2、Redis**

- Redis 有哪些数据类型，可参考《[Redis常见的5种不同的数据类型详解](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483987&idx=1&sn=5c5e4cd5bc73a7e6f84e5d6adfab0935&chksm=e9c5fbe2deb272f4b5b75bd2ac92bb27950452623ec83c0e1add7e30c773160421fab1571680&scene=21#wechat_redirect)》
- Redis 内部结构
- Redis 使用场景
- Redis 持久化机制，可参考《[使用快照和AOF将Redis数据持久化到硬盘中](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483992&idx=1&sn=8f554bc490c4db1a78a30144f873e911&chksm=e9c5fbe9deb272fff47483c241e6d2a7aae99dc8f6fe9fee31f2dd214d0cf81b33d51f7a7dbe&scene=21#wechat_redirect)》
- Redis 集群方案与实现
- Redis 为什么是单线程的？
- 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级
- 使用缓存的合理性问题
- Redis常见的回收策略

### **2.3、消息队列**

- 消息队列的使用场景
- 消息的重发补偿解决思路
- 消息的幂等性解决思路
- 消息的堆积解决思路
- 自己如何实现消息队列
- 如何保证消息的有序性

## **三、开源框架和容器**

### **3.1、SSM/Servlet**

- Servlet的生命周期
- 转发与重定向的区别
- BeanFactory 和 ApplicationContext 有什么区别
- Spring Bean 的生命周期
- Spring IOC 如何实现
- Spring中Bean的作用域，默认的是哪一个
- 说说 Spring AOP、Spring AOP 实现原理
- 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择
- Spring 事务实现方式、事务的传播机制、默认的事务类别
- Spring 事务底层原理
- Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《[JDK动态代理给Spring事务埋下的坑！](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484940&idx=1&sn=0a0a7198e96f57d610d3421b19573002&chksm=e9c5ffbddeb276ab64ff3b3efde003193902c69acda797fdc04124f6c2a786255d58817b5a5c&scene=21#wechat_redirect)》
- 如何自定义注解实现功能
- Spring MVC 运行流程
- Spring MVC 启动流程
- Spring 的单例实现原理
- Spring 框架中用到了哪些设计模式
- Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）
- 有没有用到Spring Boot，Spring Boot的认识、原理
- MyBatis的原理
- 可参考《[为什么会有Spring](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484822&idx=1&sn=6fbee2a12b31b6102a18d3725671d41b&chksm=e9c5fc27deb275319641c3f30d168b85c7c196fd276d47efa35046b5dc54f5b77174c5bf8808&scene=21#wechat_redirect)》
- 可参考《[为什么会有Spring AOP](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484827&idx=1&sn=b9d82f3fced6a875f8dfc22e5849b28e&chksm=e9c5fc2adeb2753c516ef8fc959c0c9dd84ccacaa40473b64bc58b5137c30562a0b45803ba8e&scene=21#wechat_redirect)》

### **3.2、Netty**

- 为什么选择 Netty
- 说说业务中，Netty 的使用场景
- 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
- 什么是TCP 粘包/拆包
- TCP粘包/拆包的解决办法
- Netty 线程模型
- 说说 Netty 的零拷贝
- Netty 内部执行流程
- Netty 重连实现

**3.3、Tomcat**

- Tomcat的基础架构（Server、Service、Connector、Container）
- Tomcat如何加载Servlet的
- Pipeline-Valve机制
- 可参考：《[四张图带你了解Tomcat系统架构](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484905&idx=1&sn=6c8acd89476fadbc4cb9ccfda9c9c2e4&chksm=e9c5fc58deb2754e7519511bb0ed8dcbfa3fe29179663b53f3626643f8b9c82068d9b0464ee6&scene=21#wechat_redirect)！》

## **四、分布式**

## **4.1、Nginx**

- 请解释什么是C10K问题或者知道什么是C10K问题吗？
- Nginx简介，可参考《[Nginx简介](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483994&idx=1&sn=b6591f62c7ea6b4adc5a5bf1bf4eac40&chksm=e9c5fbebdeb272fdd865a9c61a380f6b909fc988f99d00ce0aa8c3efca501644db46c40bd4f2&scene=21#wechat_redirect)》
- 正向代理和反向代理.
- Nginx几种常见的负载均衡策略
- Nginx服务器上的Master和Worker进程分别是什么
- 使用“反向代理服务器”的优点是什么?

### **4.2、分布式其他**

- 谈谈业务中使用分布式的场景
- Session 分布式方案
- Session 分布式处理
- 分布式锁的应用场景、分布式锁的产生原因、基本概念
- 分布是锁的常见解决方案
- 分布式事务的常见解决方案
- 集群与负载均衡的算法与实现
- 说说分库与分表设计，可参考《[数据库分库分表策略的具体实现方案](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483931&idx=1&sn=6eda41aa81c1243422a603205d2fad22&chksm=e9c5fbaadeb272bc92537803c14a6f55e1170b1a3b8f60160f66417800c0ace960dfe192717a&scene=21#wechat_redirect)》
- 分库与分表带来的分布式困境与应对之策

**4.3、Dubbo**

- 什么是Dubbo，可参考《[Dubbo入门](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483791&idx=1&sn=49345f1a022734e81e9257f2b8d38a52&chksm=e9c5f83edeb2712805a77c1e1589e8f1d04bd17e55eeb2a45cabddb46d03615636908f058628&scene=21#wechat_redirect)》
- 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《[基于HTTP的RPC实现](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483900&idx=1&sn=c5ca198a66a701f81c2ab118fe7a734a&chksm=e9c5f84ddeb2715bc574e467cd6537ef81f223453e0989ffd136976b48dcc2d961a75be596de&scene=21#wechat_redirect)》
- Dubbo中的SPI是什么概念
- Dubbo的基本原理、执行流程

**五、微服务**

**5.1、微服务**

- 前后端分离是如何做的？
- 微服务哪些框架
- Spring Could的常见组件有哪些？可参考《[Spring Cloud概述](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247484125&idx=1&sn=ddba9fba6ae900f5ef71a68f70afebe5&chksm=e9c5fb6cdeb2727a1e8d16a05adb7d9df0170e392ae579d1e40075fb488d680f0c061aa45327&scene=21#wechat_redirect)》
- 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型
- JWT有了解吗，什么是JWT，可参考《[前后端分离利器之JWT](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485183&idx=1&sn=05dac824dbb534710dd99d6c895fbaf5&chksm=e9c5ff4edeb27658173c8b06ad6d1241d3b7822c734ddf6ac064d40e63cb0cb0a0c90804b9c7&scene=21#wechat_redirect)》
- 你怎么理解 RESTful
- 说说如何设计一个良好的 API
- 如何理解 RESTful API 的幂等性
- 如何保证接口的幂等性
- 说说 CAP 定理、BASE 理论
- 怎么考虑数据一致性问题
- 说说最终一致性的实现方案
- 微服务的优缺点，可参考《[微服务批判](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485005&idx=1&sn=78a1d286c6a15a81ea5dcf6634a70b54&chksm=e9c5fffcdeb276ea3c766a6e5954685db0e89bea8ff0f47c9a3ff2c0c02991f791a5160287c4&scene=21#wechat_redirect)》
- 微服务与 SOA 的区别
- 如何拆分服务、水平分割、垂直分割
- 如何应对微服务的链式调用异常
- 如何快速追踪与定位问题
- 如何保证微服务的安全、认证

### **5.2、安全问题**

- 如何防范常见的Web攻击、如何方式SQL注入
- 服务端通信安全攻防
- HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比

### **5.3、性能优化**

- 性能指标有哪些
- 如何发现性能瓶颈
- 性能调优的常见手段
- 说说你在项目中如何进行性能调优

## **六、其他**

### **6.1、设计能力**

- 说说你在项目中使用过的UML图
- 你如何考虑组件化、服务化、系统拆分
- 秒杀场景如何设计
- 可参考：《[秒杀系统的技术挑战、应对策略以及架构设计总结一二！](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485294&idx=1&sn=681b3fc8833bc978344f66c8dd33ff32&chksm=e9c5fedfdeb277c96e03e8943bff709ad5354cbbe0c0d894cdb9d1e8cc8da92bf51f1e832e37&scene=21#wechat_redirect)》

### **6.2、业务工程**

- 说说你的开发流程、如何进行自动化部署的
- 你和团队是如何沟通的
- 你如何进行代码评审
- 说说你对技术与业务的理解
- 说说你在项目中遇到感觉最难Bug，是如何解决的
- 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方

### **6.3、软实力**

- 说说你的优缺点、亮点
- 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码
- 说说你觉得最有意义的技术书籍
- 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力
- 说说个人发展方向方面的思考
- 说说你认为的服务端开发工程师应该具备哪些能力
- 说说你认为的架构师是什么样的，架构师主要做什么
- 如何看待加班的问题

当然，一个完整的面试肯定不止上述的知识点，其他的诸如：Linux、数据结构、算法、逻辑思维题、系统设计题、职业规划等等都会有所涉及！总之，充分的准备是应对一切面试的不二法宝！