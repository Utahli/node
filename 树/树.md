```
某二叉树中有n个度为2的结点，则该二叉树中的叶子结点数为(A)

A) n+1
B) n-1
C) 2n
D) n/2
解：
结点的孩子结点个数即为该结点的度.
度为0的结点叫叶子结点.
处在树的最顶端(没有双亲)的结点叫根结点.

************************
该题解答:
设该二叉树总结点数为N,叶子结点个数为n0,度为1的结点个数为n1.
下面可得两等式:
(1) N = n + n0 + n1;
依据:很显然,二叉树总结点数等于度分别为0,1,2的结点个数总和.

(2) N = 2n + n1 +1;
依据:二叉树的树杆(即左右斜线)数等于总结点数减1,这个隐含的条件很关键哦!!

由(1)(2)两式即可求得: n0=n+1;

故答案为A
```



## 一、红黑树的介绍

先来看下算法导论对R-B Tree的介绍：
红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

红黑树，作为一棵二叉查找树，满足二叉查找树的一般性质。下面，来了解下二叉查找树的一般性质。

### 二叉查找树

二叉查找树，也称有序二叉树（ordered binary tree），或已排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

- 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 任意节点的左、右子树也分别为二叉查找树。
- 没有键值相等的节点（no duplicate nodes）。

因为一棵由n个结点随机构造的二叉查找树的高度为lgn，所以顺理成章，二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。

红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

但它是如何保证一棵n个结点的红黑树的高度始终保持在logn的呢？这就引出了红黑树的5个性质：

1. 每个结点要么是红的要么是黑的。  
2. 根结点是黑的。  
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
4. 如果一个结点是红的，那么它的两个儿子都是黑的。  
5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。

正是红黑树的这5条性质，使一棵n个结点的红黑树始终保持了logn的高度（红黑树的高度至多为2log(n+1)证明略），从而也就解释了上面所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论成立的原因。

此图忽略了叶子和根部的父结点。同时，上文中我们所说的 "叶结点" 或"NULL结点"，如上图所示，它不包含数据而只充当树在此结束的指示，这些节点在绘图中经常被省略，望看到此文后的读者朋友注意。 

## 二、树的旋转知识

当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。

树的旋转分为左旋和右旋，下面借助图来介绍一下左旋和右旋这两种操作。

1.左旋

![img](http://static.oschina.net/uploads/space/2016/0220/153457_Z8nT_2243330.jpg)

如上图所示，当在某个结点pivot上，做左旋操作时，我们假设它的右孩子y不是NIL[T]，pivot可以为任何不是NIL[T]的左子结点。左旋以pivot到Y之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的左孩子b则成为pivot的右孩子。

2.右旋

右旋与左旋差不多，再此不做详细介绍。

![img](http://static.oschina.net/uploads/space/2016/0220/154607_LHMO_2243330.jpg)

对于树的旋转，能保持不变的只有原树的搜索性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后可利用旋转和颜色重涂来恢复树的红黑性质。

## 三、红黑树的插入

将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：

**第一步: 将红黑树当作一颗二叉查找树，将节点插入。**
红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！

**第二步：将插入的节点着色为"红色"。**

由于性质的约束：插入点不能为黑节点，应插入红节点。因为你插入黑节点将破坏性质5，所以每次插入的点都是红结点，但是若他的父节点也为红，那岂不是破坏了性质4？对啊，所以要做一些“旋转”和一些节点的变色。

**第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。**

 第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？ 

 

​       对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。 

 

​       对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。 

 

​       对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。 

 

​       对于"特性(4)"，是有可能违背的！ 

 

​       那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。

首先来看下伪代码描述：

![img](http://static.oschina.net/uploads/space/2016/0222/152145_KF4k_2243330.gif)

根据被插入节点的父节点的情况，可以将"当节点z被着色为红色节点，并插入二叉树"划分为三种情况来处理。

① 情况说明：被插入的节点是根节点。
    处理方法：直接把此节点涂为黑色。
② 情况说明：被插入的节点的父节点是黑色。
    处理方法：什么也不需要做。节点被插入后，仍然是红黑树。
③ 情况说明：被插入的节点的父节点是红色。
    处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据"叔叔节点的情况"，将这种情况进一步划分为3种情况(Case)。

![img](http://static.oschina.net/uploads/space/2016/0222/152510_i5PN_2243330.jpg)
上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。

**1. (Case 1)叔叔是红色**

**![img](http://static.oschina.net/uploads/space/2016/0222/152721_tNQ4_2243330.png)**

插入的节点标为N（红色），父节点为P，祖父节点为G，叔节点为U，下同

N、P都为红，违反性质4；若把P改为黑，符合性质4，显然左边少了一个黑节点，违反性质5；所![img](http://my.oschina.net/hosee/admin)以我们把G，U都改为相反色，这样一来通过G的路径的黑节点数目没变，即符合4、5，但是G变红了，若G的父节点又是红的不就有违反了4，是这样，所以经过上边操作后未结束，需把G作为起始点，即把G看做一个插入的红节点继续向上检索----属于哪种情况，按那种情况操作~要么中间就结束，要么知道根结点（此时根结点变红，一根结点向上检索，那木有了，那就把他变为黑色吧）。

注意核心思路就是将红色的节点移到根节点。

**2. (Case 2)叔叔是黑色，且当前节点是右孩子**

case1中我们不考虑当前节点是左孩子还是右孩子，因为情况都相同。但是当叔叔节点为黑色时，则要考虑节点是左孩子还是右孩子。

![img](http://static.oschina.net/uploads/space/2016/0222/153925_drbm_2243330.png)

case2很简单，通过旋转生成右边的图，而右边的情况就是case3。

总之case2就是通过一次旋转，然后进行case3的判断

**3. (Case 3)叔叔是黑色，且当前节点是左孩子**

**![img](http://static.oschina.net/uploads/space/2016/0222/154207_Suvj_2243330.png)**

操作：先旋转再变色

经过P、G变换（旋转），变换后P的位置就是当年G的位置，所以红P变为黑，而黑G变为红都是为了不违反性质5，而维持到达叶节点所包含的黑节点的数目不变！还可以理解为：也就是相当于（只是相当于，并不是实事，只是为了更好理解；）把红N头上的红节点移到对面黑U的头上；这样即符合了性质4也不违反性质5，这样就结束了。

删除操作和插入操作差不多本文就不提了，请大家参看Reference。

总结：

红黑树的插入操作，当父节点为黑时，很好理解。主要是当父节点是红色时，需要区分成3种case。

case1时，发生一次着色操作，然后不断循环，每次完成case1操作后，把G赋给N，直到循环到根节点或者父节点为黑，跳出case1的情况。由于红黑树的高度至多为2log(n+1)。所以case1至多发生log(n+1)次。

case2时，发生一次旋转操作，跳到case3情形。

case3时，发生一次旋转操作，再一次着色操作。完成操作。

所以红黑树的选择操作很少。局部至多2次（插入最多两次旋转，删除最多三次旋转）。大部分都是着色操作。

少量的旋转操作使得再添加节点时，大部分节点是可以被查询/修改的（因为旋转时为了数据安全，会锁住某些节点不能被修改，而着色操作并不影响这些）。在很多底层的实现上，有大量红黑树的实现。

## 四、红黑树与AVL树的区别

红黑树旋转操作非常局部化，而且次数极少（插入最多两次旋转，删除最多三次旋转），而改变颜色的操作不会影响到用户对树的query操作（即不要lock），另外很多树，如AVL树，2-3树,2-4树都可以转化成红黑树，红黑树能达到O(logn)高度，但是不像AVL树那样严格要求左右子树高度差必需相差不超过1。可以说RB树是目前为止高度要求最灵活的准平衡BST。准平衡是相对完全二叉树来说的，AVL树(比如Fibonacci树)也不是完美平衡的。

红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。 

当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，做一个哈希表，性能可能会更好一些。 

红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组（“关联数组”是一种具有特殊索引方式的数组。不仅可以通过整数来索引它，还可以使用字符串或者其他类型的值（除了NULL）来索引它。）。

## 五、Java中的红黑树

TreeMap 和 TreeSet 是 Java Collection Framework 的两个重要成员，其中 TreeMap 是 Map 接口的常用实现类，而 TreeSet 是 Set 接口的常用实现类。虽然 HashMap 和 HashSet 实现的接口规范不同，但 TreeSet 底层是通过 TreeMap 来实现的，因此二者的实现方式完全一样。而 TreeMap 的实现就是红黑树算法。 
对于 TreeMap 而言，由于它底层采用一棵“红黑树”来保存集合中的 Entry，这意味这 TreeMap 添加元素、取出元素的性能都比 HashMap 低：当 TreeMap 添加元素时，需要通过循环找到新增 Entry 的插入位置，因此比较耗性能；当从 TreeMap 中取出元素时，需要通过循环才能找到合适的 Entry，也比较耗性能。 
但 TreeMap、TreeSet 比 HashMap、HashSet 的优势在于：TreeMap 中的所有 Entry 总是按 key 根据指定排序规则保持有序状态，TreeSet 中所有元素总是根据指定排序规则保持有序状态。 

## Reference：

1. http://blog.csdn.net/v_JULY_v/article/details/6105630

2. http://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html

3. http://www.cnblogs.com/skywang12345/p/3245399.html#aa5

4. http://www.tuicool.com/articles/FRRZnqB

5. http://www.lxway.com/852122226.htm



# [二叉树常见面试题（进阶）](https://www.cnblogs.com/33debug/p/7252371.html)

### 一、常见题型

\1. 求两个节点的最近公共祖先；

\2. 求二叉树中最远的两个节点的距离；

\3. 由前序遍历和中序遍历重建二叉树（如：前序序列：1 2 3 4 5 6 - 中序序列 ：3 2 4 1 6 5）；

\4. 判断一棵树是否是完全二叉树 ；

\5. 将二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向；

6.求二叉树的宽度；

\7. 判断一棵二叉树是否是平衡二叉树；

8.判断一颗二叉树是否是另一颗树的子树。

### 二、解题思路分析

#### 1.两个节点的最近公共祖先

求两个节点的最近公共祖先可分为三种情况，分别为：

（1）搜索二叉树，根据搜索二叉树的性质，左子树的所有节点比根节点小，右子树的所有节点比跟节点大。

![img](https://images2017.cnblogs.com/blog/1069650/201707/1069650-20170728184212836-257168436.png)
如果两个节点都比根节点小，则递归左子树 ；
如果两个节点都比跟节点大，则递归右子树 ；
否则，两个节点一个在左子树，一个在右子树，则当前节点就是最近公共祖先节点。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 Node* GetAncestor(Node* root, Node* x1, Node* x2)//1.该二叉树为搜索二叉树
 2         {
 3             assert(x1 && x2);
 4             if (x1->_data <= root->_data && x2->_data <= root->_data)
 5             {
 6                 return GetAncestor(root->_left, x1, x2);//两个节都小于根节点，最近公共祖先在左子树中
 7             }
 8             else if (x1->_data > root->_data && x2->_data > root->_data)
 9             {
10                 return GetAncestor(root->_right, x1, x2);//两个节都大于根节点，最近公共祖先在左子树中
11             }
12             else
13                 return root;  //一个在左子树，一个在右子树，找到公共祖先
14 
15         }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

（2）三叉链，二叉树节点有指向父节点的指针。首先给出node1的父节点node1->_parent，然后将node1的所有父节点依次和node2->parent作比较，如果发现两个节点相等，则该节点就是最近公共祖先，直接将其返回。如果没找到相等节点，则将node2的所有父节点依次和node1->_parent->_parent作比较......直到node1->_parent==NULL。代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     struct BinaryNode   //节点的结构
 2     {  
 3         BinaryNode* _left;  
 4         BinaryNode* _right;  
 5         BinaryNode* _parent;  
 6         int _data;  
 7       
 8         BinaryNode(const int& data)  
 9             :_data(data)  
10             , _left(NULL)  
11             , _right(NULL)  
12             , _parent(NULL)  
13         {}  
14     };  
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1   Node * GetLastCommonAncestor(Node * root, Node * node1, Node * node2)  
 2     {  
 3         Node * temp;  
 4         while (node1 != NULL)  
 5         {  
 6             node1 = node1->_parent;  
 7             temp = node2;  
 8             while (temp != NULL)  
 9             {  
10                 if (node1 == temp->_parent)  
11                     return node1;  
12                 temp = temp->_parent;  
13             }  
14         }  
15     }  
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

该算法时间复杂度为O(n^2)，可用另一种O(n)的算法：

给定的两个节点都含有父节点，因此，可将这两个节点看做是两个链表的头结点，将求两个节点的最近公共祖先节点转化为求两链表的交点，这两个链表的尾节点都是根节点。

![img](https://images2017.cnblogs.com/blog/1069650/201707/1069650-20170728190606930-701033088.png)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     int Hight(BinaryNode* root, BinaryNode* node)  
 2     {  
 3         int len = 0;  
 4         for (; node != NULL; node = node->_parent)  
 5             len++;  
 6       
 7         return len;  
 8     }  
 9     BinaryNode* GetLastCommonAncestor(BinaryNode* root, BinaryNode* node1, BinaryNode* node2)  
10     {  
11       
12         if (root == NULL || node1 == NULL || node2==NULL)  
13             return NULL;  
14       
15         int len1 = Hight(root,node1);  
16         int len2 = Hight(root,node2);  
17               
19         for (; len1 > len2; len1--)  
20             node1 = node1->_parent;  
21         for (; len2 > len1; len2--)  
22             node2 = node2->_parent;  
23       
24         while (node1 && node2 && node1 != node2)  
25         {  
26             node1 = node1->_parent;  
27             node2 = node2->_parent;  
28         }  
29           
30         if (node1 == node2)  
31             return node1;  
32         else  
33             return NULL;  
34     }  
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

（3）普通二叉树，这种情况可采用与搜索二叉树类似的解法

 从根节点开始遍历，如果node1和node2中的任一个和root匹配，那么与root匹配的节点就是最低公共祖先。 如果都不匹配，则分别递归左、右子树，如果有一个 节点出现在左子树，并且另一个节点出现在右子树，则root就是最低公共祖先.  如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 Node* GetAncestor(Node* root, Node* x1, Node* x2)
 2         {
 3             assert(x1 && x2);
 4             if (root == NULL) {
 5                 return NULL;
 6             }
 7             if (root == x1 || root == x2) //如果两个节点是父子关系，其中的一个节点为公共祖先
 8             {
 9                 return root;
10             }
11             bool x1inleft, x2inleft, x1inright, x2inright;
12             x1inleft = JudgeNode(root->_left, x1);  //判断x1是否在左子树
13             x1inright = JudgeNode(root->_right x1);  //判断x1是否在右子树
14             assert(x1inleft || x1inright);  //至少有一个为真
15             x2inleft = JudgeNode(root->_left, x2);  //判断x2是否在左子树
16             x2inright = JudgeNode(root->_right, x2);  //判断x2是否在右子树
17             assert(x2inleft || x2inright);  //至少有一个为真
18             if ((x1inleft && x2inright) || (x1inright && x2inright))
19             {
20                 return root;  //一个在左子树，一个在右子树，找到公共祖先
21             }
22             else if (x1inleft && x2inleft)  //两个节都在左子树中,最近公共祖先在左子树中
23             {
24                 return GetAncestor(root->_left, x1, x2);
25             }
26             else {  //两个节都在右子树中,最近公共祖先在右子树中
27                 return GetAncestor(root->_right, x1, x2);
28             }
29         }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

上述方法时间复杂度为O（N^2），下面的方法时间复杂度为O（N）,但是需要额外的空间来存储路径。

**1)** 找到从根到node1的路径，并存储在一个向量或数组中。
**2)**找到从根到node2的路径，并存储在一个向量或数组中。
**3)** 遍历这两条路径，直到遇到一个不同的节点，则前面的那个即为最低公共祖先.

 ![img](https://images2017.cnblogs.com/blog/1069650/201707/1069650-20170728191228977-42778129.png)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1         bool GetNodePaths(Node* root, Node* node, stack<Node *>& s)
 2         {
 3             if (root == NULL)
 4             {
 5                 return false;
 6             }
 7             s.push(root);
 8             if (root == node)
 9             {
10                 return true;
11             }
12             bool inleft = GetNodePaths(root->_left, node, s);
13             if (inleft)
14             {
15                 return true;
16             }
17             bool inright = GetNodePaths(root->_right, node, s);
18             if (inright)
19             {
20                 return true;
21             }
22             s.pop();
23             return false;
24         }
25         Node* GetAncestor(Node* root, Node* x1, Node* x2);
26         {
27             assert(x1 && x2);
28             stack<Node*> paths1, paths2;
29             if (!GetNodePaths(root->_left, x1, paths1) || !GetNodePaths(root->_right, x2, paths2))
30             {
31                 return NULL;
32             }
               else{
　　　　　　　　　　　while(paths1.size()>paths2.size()){
　　　　　　　　　　　　　　paths1.pop();
　　　　　　　　　　　}
　　　　　　　　　　　while(paths1.size()<paths2.size()){
　　　　　　　　　　　　　　paths2.pop();
　　　　　　　　　　　}
　　　　　　　　　　　while(!paths1.empty() && !paths2.empty() && paths1.top()!=paths2.top()){
　　　　　　　　　　　 　　if(paths1.top()==paths2.top())
　　　　　　　　　　　　　　　　return paths1.top();
　　　　　　　　　　　　　　paths1.pop();
　　　　　　　　　　　　　　paths2.pop();
　　　　　　　　　　　}
　　　　　　　　 }
　　　　　　　　 return NULL;
33         }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 2.最远的两个节点的距离

 第一种情况最远的两个节点的距离为它们到根节点的路径长度之和，又有可能距离最远的两个节点之间的路径不经过根节点，如图所示：

![img](https://images2017.cnblogs.com/blog/1069650/201707/1069650-20170728193128336-1461831412.png)

所以不要考虑不全，直接用两个子树的的高度相加来表示最远的两个节点的距离。有两种方法求解：

还是要借助两个子树的高度求解，但是要递归整棵树，如果子树中出现第二种情况要更新最大距离，时间复杂度为O（N^2）。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     //求二叉树中最远的两个节点的距离
 2     size_t MaxLen()
 3     {
 4         size_t maxlen = 0;
 5         _MaxLen(_root, maxlen);
 6         return maxlen;
 7     }
 8     void _MaxLen(Node* root, size_t maxlen)  //O(N^2)
 9     {
10         if (root == NULL)
11         {
12             return 0;
13         }
14         int leftdepth = Depth(root->_left);  
15         int rightdepth = Depth(root->_right);
16         if (leftdepth + rightdepth > maxlen)
17         {
18             maxlen = leftdepth + rightdepth;
19         }
20         _MaxLen(root->_left, maxlen);
21         _MaxLen(root->_right, maxlen);
22     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

另一种时间复杂度为O（N）的解法：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     size_t _MaxLen(Node* root, size_t maxlen)  //O(N)
 2     {
 3         if (root == NULL)
 4         {
 5             return;
 6         }
 7         size_t left = _MaxLen(root->_left, maxlen);
 8         size_t right = _MaxLen(root->_right, maxlen);
 9         if (right+left>maxlen)
10         {
11             maxlen = right + left;
12         }
13         return left > right ? left + 1 : right + 1;
14     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 3. 前序遍历和中序遍历重建二叉树

这个题是要用一颗二叉树的前序遍历序列和中序遍历序列，如：前序序列：1 2 3 4 5 6 - 中序序列 ：3 2 4 1 6 5，来重新构建二叉树。可以利用前序序列和中序序列中根节点的位置特性作为重建依据。图示解析过程如下：

![img](https://images2017.cnblogs.com/blog/1069650/201707/1069650-20170730115711693-273232269.png)![img](https://images2017.cnblogs.com/blog/1069650/201707/1069650-20170730115803599-1410818404.png)

创建右子树的方法与左子树的方法完全相同。当 prev 遍历完前序序列，即二叉树创建完成。代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 //由前序遍历和中序遍历重建二叉树（如：前序序列：1 2 3 4 5 6 - 中序序列 ：3 2 4 1 6 5）
 2         Node* RebulidTree(char* prev, char* inbgein, char* inend)
 3         {
 4             assert(prev && inbgein && inend);
 5             if (inbgein > inend || prev == '\0')
 6             {
 7                 return NULL;
 8             }
 9             Node* root = new Node(*prev);  //先创建根节点
10             char* div = inbgein;  //让div查找根节点
11             while (div <= inend) {
12                 if (*div == *prev)
13                 {
14                     if (inbgein <= div -1)
15                     {
16                         root->_left = RebulidTree(++prev, inbgein, div - 1);//递归创建左子树
17                     }
18                     else {
19                         root->_left = NULL;
20                     }
21                     if (div + 1 <= inend)
22                     {
23                         root->_right = RebulidTree(++prev, div + 1, inend);//递归创建右子树
24                     }
25                     else {
26                         root->_right = NULL;
27                     }
28                     break;
29                 }
30                 ++div;
31             }
32             return root;
33         }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 4. 判断一棵树是否是完全二叉树

完全二叉树： 前n-1层都是满的，第n层如有空缺，则是缺在右边，即第n层的最右边的节点，它的左边是满的，右边是空的。

这是一个层序遍历非递归法的变型题，同样要借助额外空间来临时存储节点。按照层序遍历二叉树，找到第一个只有非满结点（这个节点只有两种情况，孩子为空或者只有左没有右），如果之后的节点还有非满结点，则不是。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     bool IsComplateTree(Node* root)
 2     {
 3         queue<Node*> q;
 4         if (root)
 5         {
 6             q.push(root);  //先将节点压入队列中
 7         }
 8         //这里给一个tag是标记是否出现非满节点
 9         bool tag = true;
10         while (!q.empty())
11         {
12             Node* front = q.front();  
13             q.pop();
14             //如果已经出现过非满结点，则后面再出现有孩子的结点则一定不是完全二叉树。
15             if (front->_left)
16             {
17                 if (tag == false)
18                 {
19                     return false;
20                 }
21                 q.push(front->_left);
22             }
23             else {
24                 tag = false;
25             }
26             if (front->_right)
27             {
28                 if (tag == false)
29                 {
30                     return false;
31                 }
32                 q.push(front->_right);
33             }
34             else {
35                 tag = false;
36             }
37         }
38         return true;
39     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

第二种思路：将所有的结点全部押入队列中，每次判断队列的头如果队列头为空了则跳出循环，如果此后队列中还有元素则不是完全二叉树。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 bool IsCompleteTree(BinaryTreeNode *pRoot)
 2 {
 3          if(pRoot == NULL)
 4                return false;
 5 
 6           queue<BinaryTreeNode*> q;
 7           q.push(pRoot);
 8           BinaryTreeNode* pCur = q.front();
 9           while(pCur != NULL)
10           {
11                q.pop();
12                q.push(pCur -> left);
13                q.push(pCur -> right);
14                pCur = q.front();
15           }
16 
17           q.pop();//把空pop出来
18           //因为以经有一个空了，所以只要头不为空就不是完全二叉树
19           while(! q.empty())
20           {
21                if(q.front() != NULL)
22                     return false;
23                q.pop();
24           }
25           return true;
26 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 5. 将二叉搜索树转换成一个排序的双向链表

与二叉树的线索花化雷同

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     void _ToList(Node* cur, Node*& prev)
 2     {
 3         if (cur == NULL)
 4             return;
 5 
 6         _ToList(cur->_left, prev);
 7         // 
 8         cur->_left = prev;
 9         if(prev)
10             prev->_right = cur;
11 
12         prev = cur;
13 
14         _ToList(cur->_right, prev);
15     }
16 
17     Node* ToList(Node* root)
18     {
19         Node* prev = NULL;
20         _ToList(root, prev);
21 
22         Node* head = root;
23         while (head && head->_left)
24         {
25             head = head->_left;
26         }
27 
28         return head;
29     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 6.求二叉树的宽度

所谓二叉树的宽度是指：二叉树各层节点个数的最大值。

我们知道层序遍历二叉树是使用 queue 来实现的：每次打印一个节点之后，如果存在左右子树，则把左右子树压入 queue，那么此时的队列中可能既包含当前层的节点，也包含下一层的节点。

而我们要求的是对于特定某一层的节点的个数，因此我们需要从头结点开始，记录每一层的个数，对于当前层的每一个节点，在弹出自身之后把其左右子树压入 queue，当把当前层全部弹出队列之后，在队列中剩下的就是下一层的节点。然后比较队列的size和之前得到的maxWidth，取最大值即为队列的宽度。最终队列为空，得到的maxWidth就是二叉树的宽度！

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     int Width(Node* root)
 2     {
 3         queue<Node*> q;
 4         if (root)
 5             q.push(root);
 6         int maxwidth = 1;
 7         while (!q.empty())    
 8         {
 9             int length = q.size();
10             while (length-- > 0)    
11             {
12                 Node* front = q.front();
13                 q.pop();
14                 if (front->_left)
15                 {
16                     q.push(front->_left);
17                 }
18                 if (front->_right)
19                 {
20                     q.push(front->_right);
21                 }
22             }
23             maxwidth = maxwidth > q.size() ? maxwidth : q.size();
24         }
25         return maxwidth;
26     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 7. 二叉树是否是平衡二叉树 

二叉树中每一个节点的左右子树高度之差均小于2即为平衡二叉树。那么当一颗二叉树的所有子树都是平衡二叉树时，它本身必定为平衡二叉树，用此思想可递归判断二叉树是否是平衡二叉树。代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     //--判断一棵二叉树是否是平衡二叉树
 2     bool IsBalance(Node* root)  //O(N^2)
 3     {
 4         if (root == NULL)
 5         {
 6             return false;
 7         }
 8         int left = Depth(root->_left);
 9         int right = Depth(root->_right);  
10         return abs(right - left) < 2 && IsBalance(root->_left) && IsBalance(root->_right);
11     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

这种方法借助左右的高度比较来确定是否为二叉树，需多次遍历二叉树，时间复杂度为O（N^2）。下面是一种O（N）的算法：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     bool IsBalance(Node* root, int& depth)  //O(N)
 2     {
 3         if (root == NULL)
 4         {
 5             depth = 0;
 6             return true;
 7         }
 8         int leftdepth = 0;
 9         if (IsBalance(root->_left, leftdepth) == false)
10         {
11             return false;
12         }
13         int rightdepth = 0;
14         if (IsBalance(root->_right, rightdepth) == false)
15         {
16             return false;
17         }
18         depth = rightdepth > leftdepth ? rightdepth + 1 : leftdepth + 1;
19         return abs(leftdepth - rightdepth) < 2;
20     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

####  8.二叉树是否为另一颗树的子树

判断一颗二叉树是否是另一颗树的子树。

 先在找二叉树里找根节点，找到之后判断后续的节点是否相等，如果相等，则为子树。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1     bool JudgeNextTree(Node* next, Node* child) //两棵树的起始节点的值已经相等，在判断其他节点是否相等
 2     {
 3         if (child == NULL)
 4         {
 5             return true;
 6         }
 7         if (next == NULL)
 8         {
 9             return false;
10         }
11         if (next->_data == child->_data)    //
12         {
13             return JudgeNextTree(next->_left, child->_left) && JudgeNextTree(next->_right, child->_right);
14         }
15         else {
16             return false;  //如果左右孩子都相等，则是子树，否则不是
17         }
18     }
19     bool JudgeTree(Node* parent, Node* child) //判断child是否为parent的子树
20     {
21         if (child == NULL) //空树是任何树的子树
22         {
23             return true;
24         }
25         if (parent == NULL)  //空树没有除空树的任何子树
26         {
27             return false;
28         }
29         if (parent->_data == child->_data)  //当前节点与要查找子树的根节点相同时
30         {
31             return JudgeNextTree(parent, child);  //从相等节点开始判断是否为子树
32         }
33         else if (JudgeTree(parent->_left, child->_left) == true)  //判断当前节点的左子树是否与要查找子树的根节点相同
34         {
35             return true;
36         }
37         else {
38             return JudgeTree(parent->_right, child->_right);  //判断当前节点的右子树是否与要查找子树的根节点相同
39         }
40     }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)



# [二叉树-你必须要懂！（二叉树相关算法实现-iOS）](https://www.cnblogs.com/manji/p/4903990.html)

这几天详细了解了下二叉树的相关算法，原因是看了唐boy的一篇博客（[你会翻转二叉树吗？](http://blog.devtang.com/blog/2015/06/16/talk-about-tech-interview/)），还有一篇关于[百度的校园招聘面试经历](http://www.cocoachina.com/programmer/20151015/13687.html)，深刻体会到二叉树的重要性。于是乎，从网上收集并整理了一些关于二叉树的资料，及相关算法的实现（主要是Objective-C的，但是算法思想是相通的），以便以后复习时查阅。

## 什么是二叉树？

在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”，左子树和右子树同时也是二叉树。二叉树的子树有左右之分，并且次序不能任意颠倒。二叉树是递归定义的，所以一般二叉树的相关题目也都可以使用递归的思想来解决，当然也有一些可以使用非递归的思想解决，我下面列出的一些算法有些采用了递归，有些是非递归的。

## 什么是二叉排序树？

二叉排序树又叫二叉查找树或者二叉搜索树，它首先是一个二叉树，而且必须满足下面的条件：

1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值；

2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值

3）左、右子树也分别为二叉排序树

4）没有键值相等的节点（？可能是因为不好处理键值相等的节点到底是左节点还是右节点吧）

概念就介绍这么多，都是来自网上，下面主要看算法和具体实现代码。

## 二叉树节点定义

采用单项链表的形式，只从根节点指向孩子节点，不保存父节点。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树节点
 */
@interface BinaryTreeNode : NSObject

/**
 *  值
 */
@property (nonatomic, assign) NSInteger value;
/**
 *  左节点
 */
@property (nonatomic, strong) BinaryTreeNode *leftNode;
/**
 *  右节点
 */
@property (nonatomic, strong) BinaryTreeNode *rightNode;

@end
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 创建二叉排序树

二叉树中左右节点值本身没有大小之分，所以如果要创建二叉树，就需要考虑如何处理某个节点是左节点还是右节点，如何终止某个子树而切换到另一个子树。 因此我选择了二叉排序树，二叉排序树中对于左右节点有明确的要求，程序可以自动根据键值大小自动选择是左节点还是右节点。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  创建二叉排序树
 *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值
 *
 *  @param values 数组
 *
 *  @return 二叉树根节点
 */
+ (BinaryTreeNode *)createTreeWithValues:(NSArray *)values {
    
    BinaryTreeNode *root = nil;
    for (NSInteger i=0; i<values.count; i++) {
        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];
        root = [BinaryTree addTreeNode:root value:value];
    }
    return root;
}

/**
 *  向二叉排序树节点添加一个节点
 *
 *  @param treeNode 根节点
 *  @param value    值
 *
 *  @return 根节点
 */
+ (BinaryTreeNode *)addTreeNode:(BinaryTreeNode *)treeNode value:(NSInteger)value {
    //根节点不存在，创建节点
    if (!treeNode) {
        treeNode = [BinaryTreeNode new];
        treeNode.value = value;
        NSLog(@"node:%@", @(value));
    }
    else if (value <= treeNode.value) {
        NSLog(@"to left");
        //值小于根节点，则插入到左子树
        treeNode.leftNode = [BinaryTree addTreeNode:treeNode.leftNode value:value];
    }
    else {
        NSLog(@"to right");
        //值大于根节点，则插入到右子树
        treeNode.rightNode = [BinaryTree addTreeNode:treeNode.rightNode value:value];
    }
    
    return treeNode;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树中某个位置的节点

类似索引操作，按层次遍历，位置从0开始算。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树中某个位置的节点（按层次遍历）
 *
 *  @param index    按层次遍历树时的位置(从0开始算)
 *  @param rootNode 树根节点
 *
 *  @return 节点
 */
+ (BinaryTreeNode *)treeNodeAtIndex:(NSInteger)index inTree:(BinaryTreeNode *)rootNode {
    //按层次遍历
    if (!rootNode || index < 0) {
        return nil;
    }
    
    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
    [queueArray addObject:rootNode]; //压入根节点
    while (queueArray.count > 0) {
        
        BinaryTreeNode *node = [queueArray firstObject];
        if (index == 0) {
            return node;
        }
        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
        index--; //移除节点，index减少
        
        if (node.leftNode) {
            [queueArray addObject:node.leftNode]; //压入左节点
        }
        if (node.rightNode) {
            [queueArray addObject:node.rightNode]; //压入右节点
        }
    }
    //层次遍历完，仍然没有找到位置，返回nil
    return nil;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 先序遍历

先访问根，再遍历左子树，再遍历右子树。典型的递归思想。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  先序遍历
 *  先访问根，再遍历左子树，再遍历右子树
 *
 *  @param rootNode 根节点
 *  @param handler  访问节点处理函数
 */
+ (void)preOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler {
    if (rootNode) {
        
        if (handler) {
            handler(rootNode);
        }
        
        [self preOrderTraverseTree:rootNode.leftNode handler:handler];
        [self preOrderTraverseTree:rootNode.rightNode handler:handler];
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

调用方法如下：（用到了block）

```
NSMutableArray *orderArray = [NSMutableArray array];
[BinaryTree preOrderTraverseTree:root handler:^(BinaryTreeNode *treeNode) {
     [orderArray addObject:@(treeNode.value)];
}];
NSLog(@"先序遍历结果：%@", [orderArray componentsJoinedByString:@","]);
```

 

## 中序遍历

先遍历左子树，再访问根，再遍历右子树。

对于二叉排序树来说，中序遍历得到的序列是一个从小到大排序好的序列。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  中序遍历
 *  先遍历左子树，再访问根，再遍历右子树
 *
 *  @param rootNode 根节点
 *  @param handler  访问节点处理函数
 */
+ (void)inOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler {
    if (rootNode) {
        [self inOrderTraverseTree:rootNode.leftNode handler:handler];
        
        if (handler) {
            handler(rootNode);
        }
        
        [self inOrderTraverseTree:rootNode.rightNode handler:handler];
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 后序遍历

先遍历左子树，再遍历右子树，再访问根

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  后序遍历
 *  先遍历左子树，再遍历右子树，再访问根
 *
 *  @param rootNode 根节点
 *  @param handler  访问节点处理函数
 */
+ (void)postOrderTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler {
    if (rootNode) {
        [self postOrderTraverseTree:rootNode.leftNode handler:handler];
        [self postOrderTraverseTree:rootNode.rightNode handler:handler];
        
        if (handler) {
            handler(rootNode);
        }
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 层次遍历

按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层，因此又叫广度优先遍历。需要用到队列，在OC里可以用可变数组来实现。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  层次遍历（广度优先）
 *
 *  @param rootNode 二叉树根节点
 *  @param handler  访问节点处理函数
 */
+ (void)levelTraverseTree:(BinaryTreeNode *)rootNode handler:(void(^)(BinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    
    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
    [queueArray addObject:rootNode]; //压入根节点
    while (queueArray.count > 0) {
        
        BinaryTreeNode *node = [queueArray firstObject];
        
        if (handler) {
            handler(node);
        }
        
        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
        if (node.leftNode) {
            [queueArray addObject:node.leftNode]; //压入左节点
        }
        if (node.rightNode) {
            [queueArray addObject:node.rightNode]; //压入右节点
        }
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 二叉树的深度

二叉树的深度定义为：从根节点到叶子结点依次经过的结点形成树的一条路径,最长路径的长度为树的深度。

1）如果根节点为空，则深度为0；

2）如果左右节点都是空，则深度为1；

3）递归思想：二叉树的深度=max（左子树的深度，右子树的深度）+ 1

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树的深度
 *
 *  @param rootNode 二叉树根节点
 *
 *  @return 二叉树的深度
 */
+ (NSInteger)depthOfTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return 0;
    }
    if (!rootNode.leftNode && !rootNode.rightNode) {
        return 1;
    }
    
    //左子树深度
    NSInteger leftDepth = [self depthOfTree:rootNode.leftNode];
    //右子树深度
    NSInteger rightDepth = [self depthOfTree:rootNode.rightNode];
    
    return MAX(leftDepth, rightDepth) + 1;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 二叉树的宽度

二叉树的宽度定义为各层节点数的最大值。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树的宽度
 *
 *  @param rootNode 二叉树根节点
 *
 *  @return 二叉树宽度
 */
+ (NSInteger)widthOfTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return 0;
    }
    
    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
    [queueArray addObject:rootNode]; //压入根节点
    NSInteger maxWidth = 1; //最大的宽度，初始化为1（因为已经有根节点）
    NSInteger curWidth = 0; //当前层的宽度
    
    while (queueArray.count > 0) {
        
        curWidth = queueArray.count;
        //依次弹出当前层的节点
        for (NSInteger i=0; i<curWidth; i++) {
            BinaryTreeNode *node = [queueArray firstObject];
            [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
            //压入子节点
            if (node.leftNode) {
                [queueArray addObject:node.leftNode];
            }
            if (node.rightNode) {
                [queueArray addObject:node.rightNode];
            }
        }
        //宽度 = 当前层节点数
        maxWidth = MAX(maxWidth, queueArray.count);
    }
    
    return maxWidth;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  二叉树的所有节点数

递归思想：二叉树所有节点数=左子树节点数+右子树节点数+1

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树的所有节点数
 *
 *  @param rootNode 根节点
 *
 *  @return 所有节点数
 */
+ (NSInteger)numberOfNodesInTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return 0;
    }
    //节点数=左子树节点数+右子树节点数+1（根节点）
    return [self numberOfNodesInTree:rootNode.leftNode] + [self numberOfNodesInTree:rootNode.rightNode] + 1;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树某层中的节点数

1）根节点为空，则节点数为0；

2）层为1，则节点数为1（即根节点）

3）递归思想：二叉树第k层节点数=左子树第k-1层节点数+右子树第k-1层节点数

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树某层中的节点数
 *
 *  @param level    层
 *  @param rootNode 根节点
 *
 *  @return 层中的节点数
 */
+ (NSInteger)numberOfNodesOnLevel:(NSInteger)level inTree:(BinaryTreeNode *)rootNode {
    if (!rootNode || level < 1) { //根节点不存在或者level<0
        return 0;
    }
    if (level == 1) { //level=1，返回1（根节点）
        return 1;
    }
    //递归：level层节点数 = 左子树level-1层节点数+右子树level-1层节点数
    return [self numberOfNodesOnLevel:level-1 inTree:rootNode.leftNode] + [self numberOfNodesOnLevel:level-1 inTree:rootNode.rightNode];
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树叶子节点数

叶子节点，又叫终端节点，是左右子树都是空的节点。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树叶子节点数
 *
 *  @param rootNode 根节点
 *
 *  @return 叶子节点数
 */
+ (NSInteger)numberOfLeafsInTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return 0;
    }
    //左子树和右子树都是空，说明是叶子节点
    if (!rootNode.leftNode && !rootNode.rightNode) {
        return 1;
    }
    //递归：叶子数 = 左子树叶子数 + 右子树叶子数
    return [self numberOfLeafsInTree:rootNode.leftNode] + [self numberOfLeafsInTree:rootNode.rightNode];
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 二叉树最大距离（二叉树的直径）

二叉树中任意两个节点都有且仅有一条路径，这个路径的长度叫这两个节点的距离。二叉树中所有节点之间的距离的最大值就是二叉树的直径。

有一种解法，把这个最大距离划分了3种情况：

1）这2个节点分别在根节点的左子树和右子树上，他们之间的路径肯定经过根节点，而且他们肯定是根节点左右子树上最远的叶子节点（他们到根节点的距离=左右子树的深度）。

2）这2个节点都在左子树上

3）这2个节点都在右子树上

综上，只要取这3种情况中的最大值，就是二叉树的直径。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树最大距离（直径）
 *
 *  @param rootNode 根节点
 *
 *  @return 最大距离
 */
+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return 0;
    }
//    方案一：（递归次数较多，效率较低）
    //分3种情况：
    //1、最远距离经过根节点：距离 = 左子树深度 + 右子树深度
    NSInteger distance = [self depthOfTree:rootNode.leftNode] + [self depthOfTree:rootNode.rightNode];
    //2、最远距离在根节点左子树上，即计算左子树最远距离
    NSInteger disLeft = [self maxDistanceOfTree:rootNode.leftNode];
    //3、最远距离在根节点右子树上，即计算右子树最远距离
    NSInteger disRight = [self maxDistanceOfTree:rootNode.rightNode];
    
    return MAX(MAX(disLeft, disRight), distance);
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

这个方案效率较低，因为计算子树的深度和最远距离是分开递归的，存在重复递归遍历的情况。其实一次递归，就可以分别计算出深度和最远距离，于是有了第二种方案：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树最大距离（直径）
 *
 *  @param rootNode 根节点
 *
 *  @return 最大距离
 */
+ (NSInteger)maxDistanceOfTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return 0;
    }
//    方案2：将计算节点深度和最大距离放到一次递归中计算，方案一是分别单独递归计算深度和最远距离
    TreeNodeProperty *p = [self propertyOfTreeNode:rootNode];
    return p.distance;
}

/**
 *  计算树节点的最大深度和最大距离
 *
 *  @param rootNode 根节点
 *
 *  @return TreeNodeProperty
 */
+ (TreeNodeProperty *)propertyOfTreeNode:(BinaryTreeNode *)rootNode {
    
    if (!rootNode) {
        return nil;
    }
    
    TreeNodeProperty *left = [self propertyOfTreeNode:rootNode.leftNode];
    TreeNodeProperty *right = [self propertyOfTreeNode:rootNode.rightNode];
    TreeNodeProperty *p = [TreeNodeProperty new];
    //节点的深度depth = 左子树深度、右子树深度中最大值+1（+1是因为根节点占了1个depth）
    p.depth = MAX(left.depth, right.depth) + 1;
    //最远距离 = 左子树最远距离、右子树最远距离和横跨左右子树最远距离中最大值
    p.distance = MAX(MAX(left.distance, right.distance), left.depth+right.depth);
    
    return p;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树中某个节点到根节点的路径

既是寻路问题，又是查找节点问题。

定义一个存放路径的栈（不是队列了，但是还是用可变数组来实现的）

1）压入根节点，再从左子树中查找（递归进行的），如果未找到，再从右子树中查找，如果也未找到，则弹出根节点，再遍历栈中上一个节点。

2）如果找到，则栈中存放的节点就是路径所经过的节点。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树中某个节点到根节点的路径
 *
 *  @param treeNode 节点
 *  @param rootNode 根节点
 *
 *  @return 存放路径节点的数组
 */
+ (NSArray *)pathOfTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode {
    NSMutableArray *pathArray = [NSMutableArray array];
    [self isFoundTreeNode:treeNode inTree:rootNode routePath:pathArray];
    return pathArray;
}

/**
 *  查找某个节点是否在树中
 *
 *  @param treeNode 待查找的节点
 *  @param rootNode 根节点
 *  @param path  根节点到待查找节点的路径
 *
 *  @return YES：找到，NO：未找到
 */
+ (BOOL)isFoundTreeNode:(BinaryTreeNode *)treeNode inTree:(BinaryTreeNode *)rootNode routePath:(NSMutableArray *)path {
    
    if (!rootNode || !treeNode) {
        return NO;
    }
    
    //找到节点
    if (rootNode == treeNode) {
        [path addObject:rootNode];
        return YES;
    }
    //压入根节点，进行递归
    [path addObject:rootNode];
    //先从左子树中查找
    BOOL find = [self isFoundTreeNode:treeNode inTree:rootNode.leftNode routePath:path];
    //未找到，再从右子树查找
    if (!find) {
        find = [self isFoundTreeNode:treeNode inTree:rootNode.rightNode routePath:path];
    }
    //如果2边都没查找到，则弹出此根节点
    if (!find) {
        [path removeLastObject];
    }
    
    return find;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树中两个节点最近的公共父节点

首先需要明白，根节点肯定是二叉树中任意两个节点的公共父节点（不一定是最近的），因此二叉树中2个节点的最近公共父节点一定在从根节点到这个节点的路径上。因此我们可以先分别找到从根节点到这2个节点的路径，再从这两个路径中找到最近的公共父节点。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树中两个节点最近的公共父节点
 *
 *  @param nodeA    第一个节点
 *  @param nodeB    第二个节点
 *  @param rootNode 二叉树根节点
 *
 *  @return 最近的公共父节点
 */
+ (BinaryTreeNode *)parentOfNode:(BinaryTreeNode *)nodeA andNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode {
    if (!rootNode || !nodeA || !nodeB) {
        return nil;
    }
    if (nodeA == nodeB) {
        return nodeA;
    }
    //从根节点到节点A的路径
    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];
    //从根节点到节点B的路径
    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];
    //其中一个节点不在树中，则没有公共父节点
    if (pathA.count == 0 || pathB == 0) {
        return nil;
    }
    //从后往前推，查找第一个出现的公共节点
    for (NSInteger i = pathA.count-1; i>=0; i--) {
        for (NSInteger j = pathB.count - 1; j>=0; j--) {
            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) {
                //找到
                return [pathA objectAtIndex:i];
            }
        }
    }
    return nil;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树中两个节点之间的路径

从查找最近公共父节点衍生出来的。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树中两个节点之间的路径
 *
 *  @param nodeA    第一个节点
 *  @param nodeB    第二个节点
 *  @param rootNode 二叉树根节点
 *
 *  @return 两个节点间的路径
 */
+ (NSArray *)pathFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode {
    if (!rootNode || !nodeA || !nodeB) {
        return nil;
    }
    NSMutableArray *path = [NSMutableArray array];
    if (nodeA == nodeB) {
        [path addObject:nodeA];
        [path addObject:nodeB];
        return path;
    }
    //从根节点到节点A的路径
    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];
    //从根节点到节点B的路径
    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];
    //其中一个节点不在树中，则没有路径
    if (pathA.count == 0 || pathB == 0) {
        return nil;
    }
    //从后往前推，查找第一个出现的公共节点
    for (NSInteger i = pathA.count-1; i>=0; i--) {
        [path addObject:[pathA objectAtIndex:i]];
        for (NSInteger j = pathB.count - 1; j>=0; j--) {
            //找到公共父节点，则将pathB中后面的节点压入path
            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) {
                j++; //j++是为了避开公共父节点
                while (j<pathB.count) {
                    [path addObject:[pathB objectAtIndex:j]];
                    j++;
                }
                
                return path;
            }
        }
    }
    return nil;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 二叉树两个节点之间的距离

可以从两个节点之间的路径衍生出来。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  二叉树两个节点之间的距离
 *
 *  @param nodeA    第一个节点
 *  @param nodeB    第二个节点
 *  @param rootNode 二叉树根节点
 *
 *  @return 两个节点间的距离（-1：表示没有找到路径）
 */
+ (NSInteger)distanceFromNode:(BinaryTreeNode *)nodeA toNode:(BinaryTreeNode *)nodeB inTree:(BinaryTreeNode *)rootNode {
    if (!rootNode || !nodeA || !nodeB) {
        return -1;
    }
    if (nodeA == nodeB) {
        return 0;
    }
    //从根节点到节点A的路径
    NSArray *pathA = [self pathOfTreeNode:nodeA inTree:rootNode];
    //从根节点到节点B的路径
    NSArray *pathB = [self pathOfTreeNode:nodeB inTree:rootNode];
    //其中一个节点不在树中，则没有路径
    if (pathA.count == 0 || pathB == 0) {
        return -1;
    }
    //从后往前推，查找第一个出现的公共节点
    for (NSInteger i = pathA.count-1; i>=0; i--) {
        for (NSInteger j = pathB.count - 1; j>=0; j--) {
            //找到公共父节点
            if ([pathA objectAtIndex:i] == [pathB objectAtIndex:j]) {
                //距离=路径节点数-1 （这里要-2，因为公共父节点重复了一次）
                return (pathA.count - i) + (pathB.count - j) - 2;
            }
        }
    }
    return -1;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 翻转二叉树

你会翻转二叉树吗？如果不会，那对不起，我们不会录用你！

翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调（当然是递归的）

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  翻转二叉树（又叫：二叉树的镜像）
 *
 *  @param rootNode 根节点
 *
 *  @return 翻转后的树根节点（其实就是原二叉树的根节点）
 */
+ (BinaryTreeNode *)invertBinaryTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return nil;
    }
    if (!rootNode.leftNode && !rootNode.rightNode) {
        return rootNode;
    }
    
    [self invertBinaryTree:rootNode.leftNode];
    [self invertBinaryTree:rootNode.rightNode];
    
    BinaryTreeNode *tempNode = rootNode.leftNode;
    rootNode.leftNode = rootNode.rightNode;
    rootNode.rightNode = tempNode;
    
    return rootNode;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 判断二叉树是否完全二叉树

完全二叉树定义为：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布。

完全二叉树必须满足2个条件：

1）如果某个节点的右子树不为空，则它的左子树必须不为空

2）如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点

这里还需要理解“排在它后面的节点”，回头看看层次遍历算法，我们就能知道在层次遍历时，是从上到下从左到右遍历的，先将根节点弹出队列，再压入孩子节点，因此“排在它后面的节点”有2种情况：

1）同层次的后面的节点

2）同层次的前面的节点的孩子节点（因为遍历前面的节点时，会弹出节点，同时将孩子节点压入队列）

通过上面的分析，我们可以设置一个标志位flag，当子树满足完全二叉树时，设置flag=YES。当flag=YES而节点又破坏了完全二叉树的条件，那么它就不是完全二叉树。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  是否完全二叉树
 *  完全二叉树：若设二叉树的高度为h，除第h层外，其它各层的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布
 *
 *  @param rootNode 根节点
 *
 *  @return YES：是完全二叉树，NO：不是完全二叉树
 */
+ (BOOL)isCompleteBinaryTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return NO;
    }
    //左子树和右子树都是空，则是完全二叉树
    if (!rootNode.leftNode && !rootNode.rightNode) {
        return YES;
    }
    //左子树是空，右子树不是空，则不是完全二叉树
    if (!rootNode.leftNode && rootNode.rightNode) {
        return NO;
    }
    
    //按层次遍历节点，找到满足完全二叉树的条件：
    //条件1：如果某个节点的右子树不为空，则它的左子树必须不为空
    //条件2：如果某个节点的右子树为空，则排在它后面的节点必须没有孩子节点
    //排在该节点后面的节点有2种：1）同层次的后面的节点 2）同层次的前面的节点的孩子节点（因为遍历前面的节点的时候，会将节点从队列里pop，同时把它的孩子节点push到队列里）
    NSMutableArray *queue = [NSMutableArray array];
    [queue addObject:rootNode];
    BOOL isComplete = NO; //是否已经满足完全二叉树
    while (queue.count > 0) {
        BinaryTreeNode *node = [queue firstObject];
        [queue removeObjectAtIndex:0];
        
        //左子树为空且右子树不为空，则不是完全二叉树
        if (!node.leftNode && node.rightNode) {
            return NO;
        }
        if (isComplete && (node.leftNode || node.rightNode)) {
            //前面的节点已满足完全二叉树,如果还有孩子节点，则不是完全二叉树
            return NO;
        }
        
        //右子树为空，则已经满足完全二叉树
        if (!node.rightNode) {
            isComplete = YES;
        }
        
        //压入
        if (node.leftNode) {
            [queue addObject:node.leftNode];
        }
        if (node.rightNode) {
            [queue addObject:node.rightNode];
        }
    }
    return isComplete;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  判断二叉树是否满二叉树

 满二叉树定义为：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树

 满二叉树的一个特性是：叶子数=2^(深度-1)，因此我们可以根据这个特性来判断二叉树是否是满二叉树。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  是否满二叉树
 *  满二叉树：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树
 *
 *  @param rootNode 根节点
 *
 *  @return YES：满二叉树，NO：非满二叉树
 */
+ (BOOL)isFullBinaryTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {
        return NO;
    }
    
    //二叉树深度
    NSInteger depth = [self depthOfTree:rootNode];
    //二叉树叶子节点数
    NSInteger leafNum = [self numberOfLeafsInTree:rootNode];
    
    //满二叉树特性：叶子数=2^(深度-1)
    if (leafNum == pow(2, (depth - 1))) {
        return YES;
    }
    return NO;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

## 判断二叉树是否平衡二叉树

平衡二叉树定义为：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树又叫AVL树。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
/**
 *  是否平衡二叉树
 *  平衡二叉树：即AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
 *
 *  @param rootNode 根节点
 *
 *  @return YES：平衡二叉树，NO：非平衡二叉树
 */
+ (BOOL)isAVLBinaryTree:(BinaryTreeNode *)rootNode {
    static NSInteger height;
    if (!rootNode) {
        height = 0;
        return YES;
    }
    if (!rootNode.leftNode && !rootNode.rightNode) {
        height = 1;
        return YES;
    }
    
    BOOL isAVLLeft = [self isAVLBinaryTree:rootNode.leftNode];
    NSInteger heightLeft = height;
    BOOL isAVLRight = [self isAVLBinaryTree:rootNode.rightNode];
    NSInteger heightRight = height;
    
    height = MAX(heightLeft, heightRight)+1;
    
    if (isAVLLeft && isAVLRight && ABS(heightLeft-heightRight) <= 1) {
        return YES;
    }
    return NO;
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

##  总结

 以上就是我目前整理的一些二叉树相关的算法，算法资料和思想都来源于网络，如有错误，欢迎指正！后续如果有新的算法，我也会更新进去



```java
package Tree;

import java.util.ArrayDeque;
import java.util.Queue;
import java.util.Stack;

/**
 * Created by lenovo on 2017/9/6.
 */
public class BinaryTree {
    /*
    * 前序遍历，递归实现
    * */
    public void PreOrder(TreeNode node) {
        if (node != null) {
            System.out.print(node.val);
            PreOrder(node.left);
            PreOrder(node.right);
        }
    }

    /*
    * 前序遍历，非递归实现
    * 1，先入栈根节点，输出根节点val值，再先后入栈其右节点、左结点；
    * 2，出栈左节点，输出其val值，再入栈该左节点的右节点、左节点；直到遍历完该左节点所在子树。
    * 3，再出栈右节点，输出其val值，再入栈该右节点的右节点、左节点；直到遍历完该右节点所在子树。
    * */
    public void PreOrder1(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        if (root != null) {
            stack.push(root);
        }
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            System.out.print(node.val);
            //右结点先入栈，左结点后入栈
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
        }
    }

    /*
    * 中序遍历，递归实现
    * */
    public void InOrder(TreeNode node) {
        if (node != null) {
            InOrder(node.left);
            System.out.print(node.val);
            InOrder(node.right);
        }
    }

    /*
   * 中序遍历，非递归实现
   * 1，首先从根节点出发一路向左，入栈所有的左节点；
   * 2，出栈一个节点，输出该节点val值，查询该节点是否存在右节点，
   * 若存在则从该右节点出发一路向左入栈该右节点所在子树所有的左节点；
   * 3，若不存在右节点，则出栈下一个节点，输出节点val值，同步骤2操作；
   * 4，直到节点为null，且栈为空。
   * */
    public void InOrder1(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        while (root != null || !stack.empty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            if (!stack.empty()) {
                TreeNode node = stack.pop();
                System.out.print(node.val);
                root = node.right;
            }
        }
    }

    /*
    * 后序遍历，递归实现
    * */
    public void PostOrder(TreeNode node) {
        if (node != null) {
            PostOrder(node.left);
            PostOrder(node.right);
            System.out.print(node.val);
        }
    }

    /*
    * 层序遍历（广度优先遍历）
    * */
    public void LayerOrder(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        if (root != null) queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
}
```



# 非递归实现二叉树的遍历

```java
/**
 * 非递归的先根遍历
 * @return
 */
public String preOrderTraverse(){
    StringBuffer sb=new StringBuffer();
    //构建用于存放结点的栈
    LinkedStack<BinaryNode<T>> stack=new LinkedStack<>();

    BinaryNode<T> p=this.root;

    while (p!=null||!stack.isEmpty()){

        if (p!=null){
            //访问该结点
            sb.append(p.data+",");

            //将已访问过的结点入栈
            stack.push(p);

            //继续访问其左孩子，直到p为null
            p=p.left;

        }else { //若p=null 栈不为空,则说明已沿左子树访问完一条路径, 从栈中弹出栈顶结点,并访问其右孩子
            p=stack.pop();//获取已访问过的结点记录
            p=p.right;
        }

    }
    //去掉最后一个逗号
    if(sb.length()>0){
        return sb.toString().substring(0,sb.length()-1);
    }else {
        return sb.toString();
    }
}
```



```java
/**
* 非递归的中根遍历
* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]
* @return
*/
public String inOrderTraverse(){
   StringBuffer sb=new StringBuffer();
   //构建用于存放结点的栈
   LinkedStack<BinaryNode<T>> stack=new LinkedStack<>();

   BinaryNode<T> p=this.root;

   while (p!=null||!stack.isEmpty()){
       while (p!=null){//把左孩子都入栈,至到左孩子为null
           stack.push(p);
           p=p.left;
       }
       //如果栈不为空,因为前面左孩子已全部入栈
       if(!stack.isEmpty()){
           p=stack.pop();
           //访问p结点
           sb.append(p.data+",");
           //访问p结点的右孩子
           p=p.right;
       }
   }

   if(sb.length()>0){
       return sb.toString().substring(0,sb.length()-1);
   }else {
       return sb.toString();
   }
}
```



```java
/**
* 非递归后根遍历
* @return
*/
public String postOrderTraverse(){
   StringBuffer sb=new StringBuffer();
   //构建用于存放结点的栈
   LinkedStack<BinaryNode<T>> stack=new LinkedStack<>();

   BinaryNode<T> currentNode =this.root;
   BinaryNode<T> prev=this.root;

   while (currentNode!=null||!stack.isEmpty()){
       //把左子树加入栈中,直到叶子结点为止
       while (currentNode!=null){
           stack.push(currentNode);
           currentNode=currentNode.left;
       }

       //开始访问当前结点父结点的右孩子
       if(!stack.isEmpty()){
           //获取右孩子，先不弹出
           BinaryNode<T> temp=stack.peek().right;
           //先判断是否有右孩子或者右孩子是否已被访问过
           if(temp==null||temp==prev){//没有右孩子||右孩子已被访问过
               //如果没有右孩子或者右孩子已被访问,则弹出父结点并访问
               currentNode=stack.pop();
               //访问
               sb.append(currentNode.data+",");
               //记录已访问过的结点
               prev=currentNode;
               //置空当前结点
               currentNode=null;
           }else {
               //有右孩子,则开始遍历右子树
               currentNode=temp;
           }
       }

   }

   //去掉最后一个逗号
   if(sb.length()>0){
       return sb.toString().substring(0,sb.length()-1);
   }else {
       return sb.toString();
   }
}
```



```java
/**
* 层次遍历
* @return
*/
@Override
public String levelOrder() {
   /**
    * 存放需要遍历的结点,左结点一定优先右节点遍历
    */
   LinkedQueue<BinaryNode<T>> queue=new LinkedQueue<>();
   StringBuffer sb=new StringBuffer();
   BinaryNode<T> p=this.root;

   while (p!=null){
       //记录经过的结点
       sb.append(p.data);

       //先按层次遍历结点,左结点一定在右结点之前访问
       if(p.left!=null){
           //孩子结点入队
           queue.add(p.left);
       }

       if (p.right!=null){
           queue.add(p.right);
       }
       //访问下一个结点
       p=queue.poll();
   }
   return sb.toString();
}
```



# 蛇型遍历

两个栈：一个栈`LR`先存左孩子，再存右孩子；另一个栈`RL`先存右孩子，再存左孩子

一个标识位`flag`：等于`false`时，遍历`RL`，等于`true`时，遍历LR

遍历一个栈时，每遍历一个节点就把其左右孩子存入另外一个栈中

遍历完一个栈后，判断另一个栈是否为空，若为空则蛇型遍历结束

## 1324567

- 初始`root`存入`RL`，`flag`等于`false`

## 1237654

- 初始`root`存入`LR`，`flag`等于`true`



# 分别根据前中序遍历和后中序遍历来推二叉树的结构

1、理论分析：

[数据结构](http://lib.csdn.net/base/datastructure)的基础知识中重要的一点就是能否根据两种不同遍历序列的组合（有三种：先序+中序，先序+后序，中序+后序），唯一的确定一棵二叉树。然后就是根据二叉树的不同遍历序列（先序、中序、后序），重构二叉树。显然，这三种组合并不是都能唯一确定二叉树的，其中先序+后序就不能唯一确定一棵二叉树。

（1）根据先序遍历序列和中序遍历序列构建二叉树：
先序：ABCDEFG

中序：CBEDFAG

step1、先序遍历的第一个结点总是根结点。如上图中的二叉树，根结点为A，也是先序遍历的第一个值。先序遍历时父亲结点总是在孩子结点之前遍历。

step2、可以观察到在中序遍历中，A是第5个值（从0开始算起）。由于中序遍历顺序为：左子树，根结点，右子树。所以A左边的{CBEDF} 这四个结点属于左子树，而根结点A右边的{G}属于右子树。

step3、可以从上面的结论很轻松的得到递归式。在构建了根结点A后，我们可以根据中序遍历{CBEDF} 和{G}分别构建它的左子树和右子树。我们同时需要相应的先序遍历结果用于发现规律。我们可以由先序遍历知道左右子树的先序遍历分别是{CBEDF}和{G}。左右子树也分别为二叉树，由此可以递归来解决问题。

（2）根后序遍历序列和中序遍历序列构建二叉树：
后序：CEFDBGA

中序：CBEDFAG

step1、后序遍历的最后一个结点总是“根结点”。如上图中的二叉树，根结点为A，也是后序遍历的最后一个值。

step2、在中序遍历中找到“根节点”，但是这里要先创建右子树，因为后序遍历后面的是右子树的根节点，（这里唯一跟前序遍历不一样的是后序遍历是从后往前一个一个退的）。从中序遍历中我们可以看到{G}是A的右子树，所以先创建。

step3、后序遍历再往前退，到B，那么B是A的左子树......